class GeneticTOP:
    def __init__(self, depot, clients, m: int, L: float):
        self.depot = depot
        self.clients = clients
        self.m = m
        self.L = L
        n_clients = len(clients)
        self.population_size = min(n_clients * 15, 300)  # Scale with problem size, cap at 300
        self.generations = min(n_clients * 10, 200)      # Scale with problem size, cap at 200
        self.mutation_rate = max(0.05, 1.0 / n_clients)  # Inversely proportional to size
        self.elite_size = max(5, self.population_size // 20)  # 5% of population, min 5
        self.best_solution = None
        self.best_fitness = float('-inf')
    def create_initial_population(self):
        population = []
        for _ in range(self.population_size // 2):
            solution = self._create_greedy_solution()
            if solution:
                population.append(solution)
        while len(population) < self.population_size:
            solution = self._create_random_solution()
            if solution:
                population.append(solution)
        return population
    def _create_greedy_solution(self):
        solution = []
        available_clients = self.clients.copy()
        for _ in range(self.m):
            if not available_clients:
                break
            route = [self.depot]
            current_time = 0
            while available_clients:
                best_client = max(available_clients, key=lambda c: c.profit / (distance(route[-1], c) + distance(c, self.depot)))
                new_time = current_time + distance(route[-1], best_client) + distance(best_client, self.depot)
                if new_time <= self.L:
                    route.append(best_client)
                    current_time = new_time - distance(best_client, self.depot)
                    available_clients.remove(best_client)
                else:
                    break
            if len(route) > 1:
                route.append(self.depot)
                solution.append(route)
        return solution
    def _create_random_solution(self):
        solution = []
        available_clients = self.clients.copy()
        for _ in range(self.m):
            if not available_clients:
                break
            route = [self.depot]
            current_time = 0
            while available_clients:
                client = random.choice(available_clients)
                new_time = current_time + distance(route[-1], client) + distance(client, self.depot)
                if new_time <= self.L:
                    route.append(client)
                    current_time = new_time - distance(client, self.depot)
                    available_clients.remove(client)
                else:
                    break
            if len(route) > 1:
                route.append(self.depot)
                solution.append(route)
        return solution
    def fitness(self, solution):
        if not solution:
            return float('-inf')
        total_profit = 0
        for route in solution:
            if not self._is_route_valid(route):
                return float('-inf')
            total_profit += profit_total(route)
        return total_profit - len(solution) * 0.1
    def _is_route_valid(self, route):
        if not route or route[0] != self.depot or route[-1] != self.depot:
            return False
        return temps_total(route) <= self.L
    def selection(self, population):
        selected = []
        sorted_population = sorted(population, key=lambda x: self.fitness(x), reverse=True)
        selected.extend(copy.deepcopy(sorted_population[:self.elite_size]))
        while len(selected) < self.population_size:
            candidates = random.sample(population, 3)
            winner = max(candidates, key=lambda x: self.fitness(x))
            selected.append(copy.deepcopy(winner))
        return selected
    def crossover(self, parent1, parent2):
        if not parent1 or not parent2:
            return parent1, parent2
        child1, child2 = [], []
        used_clients1, used_clients2 = set(), set()
        for i in range(len(parent1)):
            if random.random() < 0.5 and i < len(parent1):
                route = copy.deepcopy(parent1[i])
                child1.append(route)
                used_clients1.update(c.id for c in route[1:-1])
            if random.random() < 0.5 and i < len(parent2):
                route = copy.deepcopy(parent2[i])
                child2.append(route)
                used_clients2.update(c.id for c in route[1:-1])
        remaining_clients1 = [c for c in self.clients if c.id not in used_clients1]
        remaining_clients2 = [c for c in self.clients if c.id not in used_clients2]
        while remaining_clients1 and len(child1) < self.m:
            route = self._build_route(remaining_clients1)
            if route:
                child1.append(route)
                remaining_clients1 = [c for c in remaining_clients1 if c not in route[1:-1]]
        while remaining_clients2 and len(child2) < self.m:
            route = self._build_route(remaining_clients2)
            if route:
                child2.append(route)
                remaining_clients2 = [c for c in remaining_clients2 if c not in route[1:-1]]
        return child1, child2
    def _build_route(self, available_clients):
        if not available_clients:
            return None
        route = [self.depot]
        current_time = 0
        clients_copy = available_clients.copy()
        random.shuffle(clients_copy)
        for client in clients_copy:
            new_time = current_time + distance(route[-1], client) + distance(client, self.depot)
            if new_time <= self.L:
                route.append(client)
                current_time = new_time - distance(client, self.depot)
        if len(route) > 1:
            route.append(self.depot)
            return route
        return None
    def mutation(self, solution):
        if random.random() > self.mutation_rate or not solution:
            return solution
        mutated = copy.deepcopy(solution)
        mutation_type = random.choice(['swap', 'insert', 'reverse', 'merge_split'])
        if mutation_type == 'swap' and len(mutated) >= 2:
            route_idx1, route_idx2 = random.sample(range(len(mutated)), 2)
            if len(mutated[route_idx1]) > 2 and len(mutated[route_idx2]) > 2:
                pos1 = random.randint(1, len(mutated[route_idx1])-2)
                pos2 = random.randint(1, len(mutated[route_idx2])-2)
                mutated[route_idx1][pos1], mutated[route_idx2][pos2] = mutated[route_idx2][pos2], mutated[route_idx1][pos1]
        elif mutation_type == 'insert' and mutated:
            route_idx = random.randint(0, len(mutated)-1)
            if len(mutated[route_idx]) > 3:
                pos1 = random.randint(1, len(mutated[route_idx])-2)
                pos2 = random.randint(1, len(mutated[route_idx])-2)
                client = mutated[route_idx].pop(pos1)
                mutated[route_idx].insert(pos2, client)
        elif mutation_type == 'reverse' and mutated:
            route_idx = random.randint(0, len(mutated)-1)
            if len(mutated[route_idx]) > 3:
                pos1 = random.randint(1, len(mutated[route_idx])-3)
                pos2 = random.randint(pos1+1, len(mutated[route_idx])-2)
                mutated[route_idx][pos1:pos2+1] = mutated[route_idx][pos1:pos2+1][::-1]
        elif mutation_type == 'merge_split' and len(mutated) >= 2:
            idx1, idx2 = random.sample(range(len(mutated)), 2)
            combined_clients = mutated[idx1][1:-1] + mutated[idx2][1:-1]
            if combined_clients:
                random.shuffle(combined_clients)
                mid = len(combined_clients) // 2
                route1 = [self.depot] + combined_clients[:mid] + [self.depot]
                route2 = [self.depot] + combined_clients[mid:] + [self.depot]
                if self._is_route_valid(route1) and self._is_route_valid(route2):
                    mutated[idx1] = route1
                    mutated[idx2] = route2
        return mutated
    def evolve(self):
        population = self.create_initial_population()
        generations_without_improvement = 0
        reset_count = 0
        max_resets = 3
        last_best_fitness = float('-inf')
        convergence_threshold = 0.001
        early_stop_counter = 0
        early_stop_limit = 10
        total_early_stops = 0
        max_early_stops = 3
        
        for generation in range(self.generations):
            new_population = self.selection(population)
            offspring = []
            for i in range(0, len(new_population)-1, 2):
                child1, child2 = self.crossover(new_population[i], new_population[i+1])
                offspring.extend([child1, child2])
                
            offspring = [self.mutation(sol) for sol in offspring]
            population = sorted(offspring, key=self.fitness, reverse=True)[:self.population_size]
            current_best = population[0]
            current_fitness = self.fitness(current_best)
            
            if current_fitness > self.best_fitness:
                improvement = abs((current_fitness - last_best_fitness) / last_best_fitness) if last_best_fitness != float('-inf') else float('inf')
                if improvement < convergence_threshold:
                    early_stop_counter += 1
                else:
                    early_stop_counter = 0
                
                last_best_fitness = self.best_fitness
                self.best_fitness = current_fitness
                self.best_solution = copy.deepcopy(current_best)
                generations_without_improvement = 0
            else:
                generations_without_improvement += 1
                
            if early_stop_counter >= early_stop_limit:
                total_early_stops += 1
                if total_early_stops >= max_early_stops:
                    print(f"Final convergence at generation {generation}")
                    break
                print(f"Local convergence detected at generation {generation}")
                if reset_count < max_resets:
                    print(f"Resetting population (reset {reset_count + 1}/{max_resets})")
                    population = self.create_initial_population()
                    population[0] = self.best_solution  # Keep best solution found so far
                    generations_without_improvement = 0
                    early_stop_counter = 0
                    reset_count += 1
                    last_best_fitness = self.best_fitness
                else:
                    print(f"Max resets reached at generation {generation}")
                    break
                    
            if generations_without_improvement >= 15:  # Reduced from 20
                if reset_count < max_resets:
                    print(f"Stagnation detected, resetting population (reset {reset_count + 1}/{max_resets})")
                    population = self.create_initial_population()
                    population[0] = self.best_solution
                    generations_without_improvement = 0
                    early_stop_counter = 0
                    reset_count += 1
                else:
                    print(f"Max resets reached at generation {generation}")
                    break
                    
            if generation % 10 == 0:
                print(f"Generation {generation}: Best Fitness = {self.best_fitness}")




# class AntColonyTOP:
#     def __init__(self, start_point, end_point, clients, m: int, L: float):
#         self.start_point = start_point
#         self.end_point = end_point
#         self.clients = clients
#         self.m = m  # number of routes
#         self.L = L  # time limit
        
#         # Problem size dependent parameters
#         n = len(clients)
#         self.n_ants = min(50, n * 2)  # number of ants scales with problem size
#         self.max_iterations = min(200, n * 5)
        
#         # ACO parameters
#         self.alpha = 1.0  # pheromone importance
#         self.beta = 2.0   # heuristic information importance
#         self.rho = 0.1    # evaporation rate
#         self.Q = 100.0    # pheromone deposit factor
        
#         # Initialize pheromone matrix
#         self.tau = {}
#         for i in [self.start_point] + clients + [self.end_point]:
#             self.tau[i] = {}
#             for j in [self.start_point] + clients + [self.end_point]:
#                 if i != j:
#                     self.tau[i][j] = 1.0

#         # Initialize heuristic information (eta)
#         self.eta = {}
#         for i in [self.start_point] + clients + [self.end_point]:
#             self.eta[i] = {}
#             for j in [self.start_point] + clients + [self.end_point]:
#                 if i != j:
#                     dist = distance(i, j)
#                     # Combine distance and profit in heuristic
#                     profit = j.profit if j != self.start_point and j != self.end_point else 0
#                     self.eta[i][j] = (1.0 + profit) / dist if dist > 0 else 1.0

#         # Dynamic parameters
#         self.local_search_freq = max(1, self.max_iterations // 10)
#         self.diversification_factor = 0.0
        
#         # Best solution tracking
#         self.best_solution = None
#         self.best_fitness = float('-inf')
#         self.iterations_without_improvement = 0
#         self.max_stagnation = 20

#     def _select_next_client(self, ant_route, current, available_clients):
#         if not available_clients:
#             return self.end_point

#         # Calculate remaining time
#         current_time = sum(distance(ant_route[i], ant_route[i+1]) 
#                          for i in range(len(ant_route)-1))
        
#         # Filter feasible clients
#         feasible = []
#         for client in available_clients:
#             time_to_client = distance(current, client)
#             time_to_end = distance(client, self.end_point)
#             if current_time + time_to_client + time_to_end <= self.L:
#                 feasible.append(client)
        
#         if not feasible:
#             return self.end_point

#         # Calculate selection probabilities
#         total = 0.0
#         probabilities = {}
        
#         for client in feasible:
#             # Include diversification factor in probability calculation
#             prob = ((self.tau[current][client] + self.diversification_factor) ** self.alpha * 
#                    self.eta[current][client] ** self.beta)
#             probabilities[client] = prob
#             total += prob

#         if total == 0.0:
#             return random.choice(feasible)

#         # Roulette wheel selection
#         r = random.random() * total
#         curr_sum = 0.0
#         for client in feasible:
#             curr_sum += probabilities[client]
#             if curr_sum >= r:
#                 return client
        
#         return feasible[-1]

#     def _construct_route(self, available_clients):
#         route = [self.start_point]
#         current = self.start_point
#         local_available = available_clients.copy()
        
#         while local_available:
#             next_client = self._select_next_client(route, current, local_available)
#             if next_client == self.end_point:
#                 break
#             route.append(next_client)
#             current = next_client
#             local_available.remove(next_client)
        
#         route.append(self.end_point)
#         return route

#     def _construct_solution(self):
#         available_clients = set(self.clients)
#         solution = []
        
#         for _ in range(self.m):
#             if not available_clients:
#                 break
#             route = self._construct_route(available_clients)
#             if len(route) > 2:  # Only add non-empty routes
#                 solution.append(route)
#                 available_clients -= set(route[1:-1])
        
#         return solution

#     def _local_search(self, solution):
#         improved = True
#         while improved:
#             improved = False
            
#             # 2-opt improvement for each route
#             for i, route in enumerate(solution):
#                 if len(route) <= 4:  # Need at least 2 clients for 2-opt
#                     continue
                    
#                 for j in range(1, len(route)-2):
#                     for k in range(j+1, len(route)-1):
#                         new_route = route[:j] + list(reversed(route[j:k+1])) + route[k+1:]
#                         if (temps_total(new_route) <= self.L and 
#                             profit_total(new_route) > profit_total(route)):
#                             solution[i] = new_route
#                             improved = True
            
#             # Inter-route client exchange
#             for i in range(len(solution)):
#                 for j in range(i+1, len(solution)):
#                     for pos1 in range(1, len(solution[i])-1):
#                         for pos2 in range(1, len(solution[j])-1):
#                             # Try swapping clients between routes
#                             new_route1 = (solution[i][:pos1] + 
#                                         [solution[j][pos2]] + 
#                                         solution[i][pos1+1:])
#                             new_route2 = (solution[j][:pos2] + 
#                                         [solution[i][pos1]] + 
#                                         solution[j][pos2+1:])
                            
#                             if (temps_total(new_route1) <= self.L and 
#                                 temps_total(new_route2) <= self.L):
#                                 old_profit = (profit_total(solution[i]) + 
#                                             profit_total(solution[j]))
#                                 new_profit = (profit_total(new_route1) + 
#                                             profit_total(new_route2))
                                
#                                 if new_profit > old_profit:
#                                     solution[i] = new_route1
#                                     solution[j] = new_route2
#                                     improved = True
        
#         return solution

#     def _update_pheromones(self, solutions, solution_qualities):
#         # Evaporation
#         for i in self.tau:
#             for j in self.tau[i]:
#                 self.tau[i][j] *= (1 - self.rho)

#         # Deposit new pheromones
#         for solution, quality in zip(solutions, solution_qualities):
#             deposit = self.Q * quality
#             for route in solution:
#                 for i in range(len(route)-1):
#                     self.tau[route[i]][route[i+1]] += deposit
#                     self.tau[route[i+1]][route[i]] += deposit  # Symmetric deposit

#     def _calculate_solution_quality(self, solution):
#         if not solution:
#             return 0
        
#         total_profit = sum(profit_total(route) for route in solution)
#         total_time = sum(temps_total(route) for route in solution)
        
#         # Penalize solutions that violate time constraints
#         if any(temps_total(route) > self.L for route in solution):
#             return 0
        
#         # Calculate coverage ratio
#         served_clients = len({c.id for route in solution for c in route[1:-1]})
#         coverage_ratio = served_clients / len(self.clients)
        
#         # Calculate route balance factor
#         route_lengths = [len(route) - 2 for route in solution]
#         length_variance = np.var(route_lengths) if route_lengths else 0
#         balance_factor = 1 + 0.2 * (1 / (1 + length_variance))
        
#         # Combine factors
#         quality = (total_profit * 
#                   (1 + 0.3 * coverage_ratio) * 
#                   balance_factor * 
#                   (1 - total_time / (self.m * self.L)))
        
#         return quality

#     def solve(self):
#         # Initialize elite solutions archive
#         elite_solutions = []
#         elite_size = 3
#         stagnation_counter = 0
#         last_improvement = 0
        
#         # Adaptive parameters
#         min_alpha = 0.5
#         max_alpha = 3.0
#         min_beta = 1.0
#         max_beta = 4.0
        
#         # Initialize pheromone bounds
#         tau_max = 5.0
#         tau_min = 0.01
        
#         for iteration in range(self.max_iterations):
#             solutions = []
#             qualities = []
            
#             # Adjust parameters based on stagnation
#             if stagnation_counter > 10:
#                 # Increase exploration
#                 self.alpha = max(min_alpha, self.alpha * 0.9)
#                 self.beta = min(max_beta, self.beta * 1.1)
#                 self.rho = min(0.3, self.rho * 1.1)  # Increase evaporation
#                 # Reset pheromone levels partially
#                 if stagnation_counter % 20 == 0:
#                     for i in self.tau:
#                         for j in self.tau[i]:
#                             self.tau[i][j] = max(tau_min, self.tau[i][j] * 0.5)
#             else:
#                 # Favor exploitation
#                 self.alpha = min(max_alpha, self.alpha * 1.05)
#                 self.beta = max(min_beta, self.beta * 0.95)
#                 self.rho = max(0.1, self.rho * 0.95)

#             # Construct solutions with varying randomness
#             for ant in range(self.n_ants):
#                 # Adjust randomness based on ant index
#                 exploration_factor = 1.0 - (ant / self.n_ants)
#                 temp_alpha = self.alpha * (1 + exploration_factor * 0.5)
#                 temp_beta = self.beta * (1 - exploration_factor * 0.3)
                
#                 self.alpha, temp_alpha = temp_alpha, self.alpha  # Temporarily modify parameters
#                 self.beta, temp_beta = temp_beta, self.beta
                
#                 solution = self._construct_solution()
                
#                 # Restore original parameters
#                 self.alpha, self.beta = temp_alpha, temp_beta
                
#                 # Apply immediate local search to promising solutions
#                 if ant < self.n_ants // 4:  # Apply to top 25% of ants
#                     solution = self._local_search(solution)
                
#                 quality = self._calculate_solution_quality(solution)
#                 solutions.append(solution)
#                 qualities.append(quality)
                
#                 # Update best solution
#                 if quality > self.best_fitness:
#                     self.best_fitness = quality
#                     self.best_solution = copy.deepcopy(solution)
#                     last_improvement = iteration
#                     stagnation_counter = 0
                    
#                     # Update elite solutions
#                     elite_solutions.append((solution, quality))
#                     elite_solutions.sort(key=lambda x: x[1], reverse=True)
#                     elite_solutions = elite_solutions[:elite_size]
                
#             # Update pheromones with elite reinforcement
#             self._update_pheromones(solutions, qualities)
            
#             # Additional pheromone update from elite solutions
#             if elite_solutions:
#                 elite_deposit = self.Q * 2  # Stronger influence from elite solutions
#                 for elite_sol, elite_qual in elite_solutions:
#                     for route in elite_sol:
#                         for i in range(len(route)-1):
#                             self.tau[route[i]][route[i+1]] += elite_deposit
#                             self.tau[route[i+1]][route[i]] += elite_deposit
            
#             # Enforce pheromone bounds
#             for i in self.tau:
#                 for j in self.tau[i]:
#                     self.tau[i][j] = min(tau_max, max(tau_min, self.tau[i][j]))
            
#             # Dynamic convergence criteria
#             stagnation_counter += 1
#             if stagnation_counter >= 30 and iteration > 50:  # Minimum iterations before early stop
#                 if self.best_fitness >= 0.95 * max(qualities):  # Within 5% of current best
#                     print(f"Converged at iteration {iteration}")
#                     break
            
#             # Restart mechanism
#             if iteration - last_improvement > 40:  # No improvement for 40 iterations
#                 print(f"Restarting at iteration {iteration}")
#                 # Preserve best solution but reset pheromones partially
#                 for i in self.tau:
#                     for j in self.tau[i]:
#                         self.tau[i][j] = max(tau_min, min(tau_max, 
#                                         self.tau[i][j] * 0.5 + random.random() * 0.5))
#                 last_improvement = iteration  # Reset counter
#                 stagnation_counter = 0
                
#             if iteration % 10 == 0:
#                 print(f"Iteration {iteration}: Best Fitness = {self.best_fitness}")
                
#         return self.best_solution



# class GeneticTOP:
#     def __init__(self, start_point, end_point, clients, m: int, L: float):
#         self.start_point = start_point
#         self.end_point = end_point
#         self.clients = clients
#         self.m = m
#         self.L = L
#         n = len(clients)
#         self.population_size = min(100, n * 4)
#         self.tournament_size = max(3, self.population_size // 20)
#         self.elite_size = max(2, self.population_size // 10)
#         self.generations = min(150, n * 8)
#         self.mutation_rate = min(0.3, 1.0 / n)
#         self.best_solution = None
#         self.best_fitness = float('-inf')
#         self.convergence_generations = 15
#         self.convergence_threshold = 0.001
#         self.max_distance = max(distance(c1, c2) for c1 in clients for c2 in clients)
#         self.total_possible_profit = sum(c.profit for c in clients)

#     def _route_fitness(self, route):
#         if len(route) < 3 or route[0] != self.start_point or route[-1] != self.end_point:
#             return 0
#         time = sum(distance(route[i], route[i+1]) for i in range(len(route)-1))
#         if time > self.L:
#             return 0
#         profit = sum(c.profit for c in route[1:-1])
#         time_ratio = time / self.L
#         efficiency_bonus = 1 + 0.2 * (time_ratio if time_ratio <= 0.95 else 2 - time_ratio)
#         profit_per_time = profit / time if time > 0 else 0
#         density_bonus = 1 + 0.1 * (profit_per_time / (self.total_possible_profit / self.L))
#         return profit * efficiency_bonus * density_bonus

#     def fitness(self, solution):
#         if not solution:
#             return 0
#         total_profit = sum(self._route_fitness(route) for route in solution)
#         served_clients = len({c.id for route in solution for c in route[1:-1]})
#         coverage_ratio = served_clients / len(self.clients)
#         coverage_bonus = 1 + 0.3 * coverage_ratio
#         route_lengths = [len(route) - 2 for route in solution]
#         length_variance = np.var(route_lengths) if route_lengths else 0
#         balance_bonus = 1 + 0.2 * (1 / (1 + length_variance))
#         return total_profit * coverage_bonus * balance_bonus

#     # def _create_initial_route(self):
#     #     available = set(self.clients)
#     #     route = [self.start_point]
#     #     current_time = 0
#     #     while available and current_time < self.L:
#     #         candidates = [(c, c.profit/distance(route[-1], c)) for c in available]
#     #         if not candidates:
#     #             break
#     #         client = max(candidates, key=lambda x: x[1])[0]
#     #         new_time = current_time + distance(route[-1], client) + distance(client, self.end_point)
#     #         if new_time <= self.L:
#     #             route.append(client)
#     #             available.remove(client)
#     #             current_time = new_time - distance(client, self.end_point)
#     #         else:
#     #             break
#     #     route.append(self.end_point)
#     #     return route if len(route) > 2 else None
#     def _create_initial_route(self):
#         available = list(self.clients)
#         route = [self.start_point]
#         current_time = 0
        
#         while available and current_time < self.L:
#             # Add randomization to selection
#             randomization_factor = random.random() * 0.3  # 30% randomness
#             candidates = []
#             for c in available:
#                 profit_distance_ratio = c.profit/distance(route[-1], c)
#                 randomized_score = profit_distance_ratio * (1 + randomization_factor)
#                 candidates.append((c, randomized_score))
                
#             client = max(candidates, key=lambda x: x[1])[0]
#             new_time = current_time + distance(route[-1], client) + distance(client, self.end_point)
            
#             if new_time <= self.L:
#                 route.append(client)
#                 available.remove(client)
#                 current_time = new_time - distance(client, self.end_point)
#             else:
#                 break
                
#         route.append(self.end_point)
#         return route if len(route) > 2 else None

#     def _create_initial_solution(self):
#         solution = []
#         for _ in range(self.m):
#             route = self._create_initial_route()
#             if route:
#                 solution.append(route)
#         return solution

#     def crossover(self, parent1, parent2):
#         if not parent1 or not parent2:
#             return parent1, parent2
#         child1, child2 = [], []
#         used1, used2 = set(), set()
#         for i in range(min(len(parent1), len(parent2))):
#             route1, route2 = parent1[i], parent2[i]
#             if random.random() < 0.5:
#                 route1, route2 = route2, route1
#             new_route1 = [self.start_point] + [c for c in route1[1:-1] if c.id not in used1] + [self.end_point]
#             new_route2 = [self.start_point] + [c for c in route2[1:-1] if c.id not in used2] + [self.end_point]
#             used1.update(c.id for c in new_route1[1:-1])
#             used2.update(c.id for c in new_route2[1:-1])
#             if len(new_route1) > 2:
#                 child1.append(new_route1)
#             if len(new_route2) > 2:
#                 child2.append(new_route2)
#         return child1, child2

#     def mutation(self, solution):
#         if not solution or random.random() > self.mutation_rate:
#             return solution
#         mutated = copy.deepcopy(solution)
#         mutation_type = random.random()
#         if mutation_type < 0.4 and len(mutated) >= 2:
#             i, j = random.sample(range(len(mutated)), 2)
#             if len(mutated[i]) > 2 and len(mutated[j]) > 2:
#                 pos1 = random.randint(1, len(mutated[i])-2)
#                 pos2 = random.randint(1, len(mutated[j])-2)
#                 mutated[i][pos1], mutated[j][pos2] = mutated[j][pos2], mutated[i][pos1]
#         elif mutation_type < 0.7:
#             i = random.randint(0, len(mutated)-1)
#             if len(mutated[i]) > 3:
#                 pos1, pos2 = sorted(random.sample(range(1, len(mutated[i])-1), 2))
#                 mutated[i][pos1:pos2] = reversed(mutated[i][pos1:pos2])
#         else:
#             i = random.randint(0, len(mutated)-1)
#             if len(mutated[i]) > 3:
#                 pos = random.randint(1, len(mutated[i])-2)
#                 client = mutated[i].pop(pos)
#                 for j, route in enumerate(mutated):
#                     if j != i and temps_total(route[:-1] + [client, route[-1]]) <= self.L:
#                         route.insert(-1, client)
#                         break
#         return mutated

#     def evolve(self):
#         population = [self._create_initial_solution() for _ in range(self.population_size)]
#         best_fitness_counter = 0
#         for generation in range(self.generations):
#             population.sort(key=self.fitness, reverse=True)
#             current_best_fitness = self.fitness(population[0])
#             if current_best_fitness > self.best_fitness * (1 + self.convergence_threshold):
#                 self.best_fitness = current_best_fitness
#                 self.best_solution = copy.deepcopy(population[0])
#                 best_fitness_counter = 0
#             else:
#                 best_fitness_counter += 1
#             if best_fitness_counter >= self.convergence_generations:
#                 print(f"Early stopping at generation {generation}")
#                 break
#             new_population = population[:self.elite_size]
#             while len(new_population) < self.population_size:
#                 tournament = random.sample(population, self.tournament_size)
#                 parent1 = max(tournament, key=self.fitness)
#                 tournament = random.sample(population, self.tournament_size)
#                 parent2 = max(tournament, key=self.fitness)
#                 child1, child2 = self.crossover(parent1, parent2)
#                 child1, child2 = self.mutation(child1), self.mutation(child2)
#                 if child1:
#                     new_population.append(child1)
#                 if child2 and len(new_population) < self.population_size:
#                     new_population.append(child2)
#             population = new_population[:self.population_size]
#             if generation % 10 == 0:
#                 print(f"Generation {generation}: Best Fitness = {self.best_fitness}")
#         return self.best_solution

# class GeneticTOP:
#     def __init__(self, start_point, end_point, clients, m: int, L: float):
#         self.start_point = start_point
#         self.end_point = end_point
#         self.clients = clients
#         self.m = m  # number of routes
#         self.L = L  # time limit
        
#         # Problem size dependent parameters
#         n = len(clients)
#         self.population_size = min(200, n * 4)  # Increased population size
#         self.tournament_size = max(4, self.population_size // 15)
#         self.elite_size = max(2, self.population_size // 20)  # Reduced elite size
#         self.generations = min(300, n * 10)  # Increased generations
#         self.mutation_rate = 0.2  # Fixed higher mutation rate
#         self.crossover_rate = 0.8
        
#         # Initialize statistics
#         self.best_solution = None
#         self.best_fitness = float('-inf')
#         self.generations_without_improvement = 0
#         self.max_stagnation = 30
        
#         # Precompute problem metrics
#         self.max_distance = max(distance(c1, c2) for c1 in clients for c2 in clients)
#         self.total_profit = sum(c.profit for c in clients)
#         self.avg_profit = self.total_profit / len(clients)
        
#     def _create_initial_route(self, available_clients):
#         """Creates a single route using a randomized construction heuristic"""
#         if not available_clients:
#             return None
            
#         route = [self.start_point]
#         current_time = 0
#         remaining = available_clients.copy()
        
#         while remaining:
#             # Calculate feasible next clients
#             feasible = []
#             for client in remaining:
#                 new_time = (current_time + 
#                            distance(route[-1], client) + 
#                            distance(client, self.end_point))
#                 if new_time <= self.L:
#                     feasible.append((client, new_time))
            
#             if not feasible:
#                 break
                
#             # Selection mechanism with randomization
#             if random.random() < 0.7:  # 70% greedy, 30% random
#                 # Greedy selection based on profit/distance ratio
#                 next_client = max(feasible, 
#                                 key=lambda x: (x[0].profit / 
#                                              (distance(route[-1], x[0]) + 0.1)))[0]
#             else:
#                 # Random selection from top half of feasible clients
#                 sorted_feasible = sorted(feasible, 
#                                       key=lambda x: (x[0].profit / 
#                                                    (distance(route[-1], x[0]) + 0.1)),
#                                       reverse=True)
#                 candidates = sorted_feasible[:max(1, len(sorted_feasible)//2)]
#                 next_client = random.choice(candidates)[0]
            
#             route.append(next_client)
#             remaining.remove(next_client)
#             current_time += distance(route[-2], next_client)
            
#         route.append(self.end_point)
#         return route if len(route) > 2 else None
        
#     def _create_initial_solution(self):
#         """Creates a complete solution with multiple routes"""
#         solution = []
#         available_clients = set(self.clients)
        
#         # Create routes with different construction strategies
#         if random.random() < 0.5:  # Balanced approach
#             clients_per_route = len(available_clients) // self.m
#             for _ in range(self.m):
#                 if not available_clients:
#                     break
#                 route = self._create_initial_route(set(random.sample(
#                     list(available_clients), 
#                     min(clients_per_route * 2, len(available_clients))
#                 )))
#                 if route:
#                     solution.append(route)
#                     available_clients -= set(route[1:-1])
#         else:  # Sequential approach
#             for _ in range(self.m):
#                 if not available_clients:
#                     break
#                 route = self._create_initial_route(available_clients)
#                 if route:
#                     solution.append(route)
#                     available_clients -= set(route[1:-1])
        
#         return solution
        
#     def _route_fitness(self, route):
#         """Evaluates fitness of a single route"""
#         if len(route) < 3 or route[0] != self.start_point or route[-1] != self.end_point:
#             return 0
            
#         total_time = temps_total(route)
#         if total_time > self.L:
#             return 0
            
#         total_profit = sum(c.profit for c in route[1:-1])
        
#         # Multiple optimization objectives
#         time_efficiency = 1 - (total_time / self.L)  # Reward shorter routes
#         profit_density = total_profit / total_time if total_time > 0 else 0
#         normalized_profit = total_profit / self.avg_profit
        
#         # Combined fitness with weights
#         return (total_profit * 
#                 (1 + 0.3 * time_efficiency) * 
#                 (1 + 0.2 * profit_density / self.max_distance) * 
#                 (1 + 0.1 * normalized_profit))
        
#     def fitness(self, solution):
#         """Evaluates fitness of complete solution"""
#         if not solution:
#             return 0
            
#         # Calculate basic metrics
#         route_fitness = sum(self._route_fitness(route) for route in solution)
#         served_clients = len({c.id for route in solution for c in route[1:-1]})
        
#         # Calculate optimization objectives
#         coverage_ratio = served_clients / len(self.clients)
#         route_balance = 1 - (max(len(r)-2 for r in solution) - 
#                            min(len(r)-2 for r in solution)) / len(self.clients)
        
#         # Penalize solutions with too few routes if capacity allows
#         route_penalty = 1.0
#         if len(solution) < self.m and served_clients < len(self.clients):
#             route_penalty = len(solution) / self.m
            
#         return (route_fitness * 
#                 (1 + 0.4 * coverage_ratio) * 
#                 (1 + 0.2 * route_balance) * 
#                 route_penalty)
        
#     def crossover(self, parent1, parent2):
#         """Implements an advanced crossover operator with proper client handling"""
#         if not parent1 or not parent2 or random.random() > self.crossover_rate:
#             return copy.deepcopy(parent1), copy.deepcopy(parent2)
            
#         child1, child2 = [], []
#         used_clients1, used_clients2 = set(), set()
        
#         # Determine crossover points for each route
#         for i in range(min(len(parent1), len(parent2))):
#             route1 = parent1[i] if i < len(parent1) else None
#             route2 = parent2[i] if i < len(parent2) else None
            
#             if route1 and route2:
#                 # Route-level crossover
#                 if random.random() < 0.5:
#                     # Exchange complete routes - ensure deep copy
#                     new_route1 = [self.start_point] + [
#                         next(c for c in self.clients if c.id == client.id)
#                         for client in route2[1:-1]
#                         if client.id not in used_clients1
#                     ] + [self.end_point]
                    
#                     new_route2 = [self.start_point] + [
#                         next(c for c in self.clients if c.id == client.id)
#                         for client in route1[1:-1]
#                         if client.id not in used_clients2
#                     ] + [self.end_point]
#                 else:
#                     # Two-point crossover within routes
#                     pos1, pos2 = sorted(random.sample(range(1, min(len(route1), len(route2)) - 1), 2))
                    
#                     # Create new routes with proper client references
#                     new_route1 = [self.start_point] + [
#                         next(c for c in self.clients if c.id == client.id)
#                         for client in (route1[1:pos1] + route2[pos1:pos2] + route1[pos2:-1])
#                         if client.id not in used_clients1
#                     ] + [self.end_point]
                    
#                     new_route2 = [self.start_point] + [
#                         next(c for c in self.clients if c.id == client.id)
#                         for client in (route2[1:pos1] + route1[pos1:pos2] + route2[pos2:-1])
#                         if client.id not in used_clients2
#                     ] + [self.end_point]
                
#                 if len(new_route1) > 2:
#                     child1.append(new_route1)
#                     used_clients1.update(c.id for c in new_route1[1:-1])
#                 if len(new_route2) > 2:
#                     child2.append(new_route2)
#                     used_clients2.update(c.id for c in new_route2[1:-1])
        
#         # Add remaining feasible routes from parents with proper client references
#         remaining_routes = (parent1[len(child1):] if len(child1) < self.m else [])
#         for route in remaining_routes:
#             new_route = [self.start_point] + [
#                 next(c for c in self.clients if c.id == client.id)
#                 for client in route[1:-1]
#                 if client.id not in used_clients1
#             ] + [self.end_point]
#             if len(new_route) > 2:
#                 child1.append(new_route)
#                 used_clients1.update(c.id for c in new_route[1:-1])
                
#         remaining_routes = (parent2[len(child2):] if len(child2) < self.m else [])
#         for route in remaining_routes:
#             new_route = [self.start_point] + [
#                 next(c for c in self.clients if c.id == client.id)
#                 for client in route[1:-1]
#                 if client.id not in used_clients2
#             ] + [self.end_point]
#             if len(new_route) > 2:
#                 child2.append(new_route)
#                 used_clients2.update(c.id for c in new_route[1:-1])
                
#         return child1, child2
        
#     def mutation(self, solution):
#         """Implements multiple mutation operators"""
#         if not solution or random.random() > self.mutation_rate:
#             return solution
            
#         mutated = copy.deepcopy(solution)
        
#         # Select mutation operator
#         mutation_type = random.random()
        
#         if mutation_type < 0.3 and len(mutated) >= 2:
#             # Swap clients between routes
#             route1, route2 = random.sample(mutated, 2)
#             if len(route1) > 2 and len(route2) > 2:
#                 pos1 = random.randint(1, len(route1)-2)
#                 pos2 = random.randint(1, len(route2)-2)
#                 route1[pos1], route2[pos2] = route2[pos2], route1[pos1]
                
#         elif mutation_type < 0.6:
#             # Reverse subsequence in route
#             route = random.choice(mutated)
#             if len(route) > 3:
#                 pos1, pos2 = sorted(random.sample(range(1, len(route)-1), 2))
#                 route[pos1:pos2+1] = reversed(route[pos1:pos2+1])
                
#         elif mutation_type < 0.8:
#             # Move client to another route
#             if len(mutated) > 1:
#                 source_idx = random.randint(0, len(mutated)-1)
#                 target_idx = random.randint(0, len(mutated)-1)
#                 if source_idx != target_idx and len(mutated[source_idx]) > 3:
#                     pos = random.randint(1, len(mutated[source_idx])-2)
#                     client = mutated[source_idx].pop(pos)
#                     insert_pos = random.randint(1, len(mutated[target_idx])-1)
#                     mutated[target_idx].insert(insert_pos, client)
                    
#         else:
#             # Add new route or merge routes
#             if len(mutated) < self.m:
#                 # Try to create new route from unvisited clients
#                 used = {c.id for route in mutated for c in route[1:-1]}
#                 available = [c for c in self.clients if c.id not in used]
#                 if available:
#                     new_route = self._create_initial_route(set(available))
#                     if new_route:
#                         mutated.append(new_route)
#             elif len(mutated) > 1:
#                 # Merge two routes
#                 idx1, idx2 = random.sample(range(len(mutated)), 2)
#                 route1 = mutated[idx1]
#                 route2 = mutated[idx2]
#                 merged = ([self.start_point] + 
#                          list(route1[1:-1]) + 
#                          list(route2[1:-1]) + 
#                          [self.end_point])
#                 if temps_total(merged) <= self.L:
#                     mutated.pop(max(idx1, idx2))
#                     mutated.pop(min(idx1, idx2))
#                     mutated.append(merged)
                    
#         return mutated
        
#     def evolve(self):
#         """Main evolution loop with advanced features"""
#         # Initialize population with diversity
#         population = []
#         for _ in range(self.population_size):
#             solution = self._create_initial_solution()
#             population.append(solution)
            
#         # Track population statistics
#         convergence_window = []
#         diversity_history = []
        
#         for generation in range(self.generations):
#             # Sort population by fitness
#             population.sort(key=self.fitness, reverse=True)
#             current_best_fitness = self.fitness(population[0])
#             if generation % 10 == 0:
#                 print(f"Generation {generation}: Best Fitness = {self.best_fitness}")
#             # Update best solution
#             if current_best_fitness > self.best_fitness:
#                 self.best_fitness = current_best_fitness
#                 self.best_solution = copy.deepcopy(population[0])
#                 self.generations_without_improvement = 0
#             else:
#                 self.generations_without_improvement += 1
                
#             # Calculate population diversity
#             diversity = len(set(tuple(sorted(c.id for route in sol 
#                                     for c in route[1:-1])) 
#                             for sol in population[:len(population)//2]))
#             diversity_history.append(diversity)
            
#             # Adaptive parameters based on diversity
#             if len(diversity_history) > 10:
#                 if statistics.mean(diversity_history[-10:]) < diversity_history[0] / 4:
#                     self.mutation_rate = min(0.4, self.mutation_rate * 1.1)
#                     self.tournament_size = max(2, self.tournament_size - 1)
#                 else:
#                     self.mutation_rate = max(0.1, self.mutation_rate * 0.95)
#                     self.tournament_size = min(self.population_size // 10, 
#                                             self.tournament_size + 1)
                    
#             # Create new population
#             new_population = population[:self.elite_size]
            
#             # Tournament selection and reproduction
#             while len(new_population) < self.population_size:
#                 # Tournament selection
#                 tournament1 = random.sample(population, self.tournament_size)
#                 parent1 = max(tournament1, key=self.fitness)
#                 tournament2 = random.sample(population, self.tournament_size)
#                 parent2 = max(tournament2, key=self.fitness)
                
#                 # Crossover and mutation
#                 child1, child2 = self.crossover(parent1, parent2)
                
#                 # Apply mutation with adaptive rate
#                 child1 = self.mutation(child1)
#                 child2 = self.mutation(child2)
                
#                 # Add children to new population
#                 if child1 and len(child1) > 0:
#                     new_population.append(child1)
#                 if child2 and len(child2) > 0 and len(new_population) < self.population_size:
#                     new_population.append(child2)
            
#             # Replace population
#             population = new_population
            
#             # Check for convergence
#             convergence_window.append(current_best_fitness)
#             if len(convergence_window) > 20:
#                 convergence_window.pop(0)
#                 std_dev = statistics.stdev(convergence_window)
#                 mean_fitness = statistics.mean(convergence_window)
                
#                 # If population converged (low diversity) and stagnated
#                 if (self.generations_without_improvement > self.max_stagnation and 
#                     std_dev / mean_fitness < 0.01):
                    
#                     # Partial population restart
#                     num_to_replace = self.population_size // 3
#                     population[-num_to_replace:] = [self._create_initial_solution() 
#                                                 for _ in range(num_to_replace)]
                    
#                     # Reset adaptation parameters
#                     self.mutation_rate = 0.2
#                     self.tournament_size = max(4, self.population_size // 15)
#                     self.generations_without_improvement = 0
                    
#             # Early stopping if optimal solution found or stagnation
#             if (self.generations_without_improvement > self.max_stagnation * 2 or
#                 abs(current_best_fitness - self.total_profit) < 1e-6):
#                 print(f"Early stopping at generation {generation}")
#                 break
                
#         return self.best_solution



# class AntColonyTOP:
#     def __init__(self, start_point, end_point, clients, m: int, L: float):
#         self.start_point = start_point
#         self.end_point = end_point
#         self.clients = clients
#         self.m = m  # number of routes
#         self.L = L  # time limit
        
#         # Problem size dependent parameters
#         n = len(clients)
#         self.n_ants = min(50, n * 2)
#         self.max_iterations = min(200, n * 5)
        
#         # ACO parameters
#         self.alpha = 1.0
#         self.beta = 2.0
#         self.rho = 0.1
#         self.Q = 100.0
        
#         # Initialize pheromone matrix
#         self.tau = {}
#         for i in [self.start_point] + clients + [self.end_point]:
#             self.tau[i] = {}
#             for j in [self.start_point] + clients + [self.end_point]:
#                 if i != j:
#                     self.tau[i][j] = 1.0

#         # Initialize heuristic information
#         self.eta = {}
#         for i in [self.start_point] + clients + [self.end_point]:
#             self.eta[i] = {}
#             for j in [self.start_point] + clients + [self.end_point]:
#                 if i != j:
#                     dist = self.get_distance(i, j)
#                     profit = j.profit if j != self.start_point and j != self.end_point else 0
#                     self.eta[i][j] = (1.0 + profit) / dist if dist > 0 else 1.0

#         self.best_solution = None
#         self.best_fitness = float('-inf')

#     def get_distance(self, client1, client2):
#         return math.sqrt((client1.x - client2.x) ** 2 + (client1.y - client2.y) ** 2)

#     def is_valid_route(self, route):
#         if not route or len(route) < 2:
#             return False
#         if route[0] != self.start_point or route[-1] != self.end_point:
#             return False
#         if len(set(c.id for c in route[1:-1])) != len(route[1:-1]):
#             return False
#         total_time = sum(self.get_distance(route[i], route[i+1]) for i in range(len(route)-1))
#         return total_time <= self.L

#     def _select_next_client(self, ant_route, current, available_clients):
#         if not available_clients:
#             return self.end_point

#         # Calculate remaining time
#         current_time = sum(self.get_distance(ant_route[i], ant_route[i+1]) 
#                          for i in range(len(ant_route)-1))
        
#         # Filter feasible clients
#         feasible = []
#         for client in available_clients:
#             temp_route = ant_route + [client, self.end_point]
#             if self.is_valid_route(temp_route):
#                 feasible.append(client)
        
#         if not feasible:
#             return self.end_point

#         # Calculate selection probabilities
#         total = 0.0
#         probabilities = {}
        
#         for client in feasible:
#             prob = (self.tau[current][client] ** self.alpha * 
#                    self.eta[current][client] ** self.beta)
#             probabilities[client] = prob
#             total += prob

#         if total == 0.0:
#             return random.choice(feasible)

#         # Roulette wheel selection
#         r = random.random() * total
#         curr_sum = 0.0
#         for client in feasible:
#             curr_sum += probabilities[client]
#             if curr_sum >= r:
#                 return client
        
#         return feasible[-1]

#     def _construct_route(self, available_clients):
#         route = [self.start_point]
#         current = self.start_point
#         local_available = available_clients.copy()
        
#         while local_available:
#             next_client = self._select_next_client(route, current, local_available)
#             if next_client == self.end_point:
#                 break
            
#             test_route = route + [next_client]
#             if not self.is_valid_route(test_route + [self.end_point]):
#                 break
                
#             route.append(next_client)
#             current = next_client
#             local_available.remove(next_client)
        
#         route.append(self.end_point)
#         return route if self.is_valid_route(route) else [self.start_point, self.end_point]

#     def _construct_solution(self):
#         available_clients = set(self.clients)
#         solution = []
        
#         for _ in range(self.m):
#             if not available_clients:
#                 break
#             route = self._construct_route(available_clients)
#             if len(route) > 2 and self.is_valid_route(route):
#                 solution.append(route)
#                 available_clients -= set(route[1:-1])
        
#         return solution

#     def _local_search(self, solution):
#         improved = True
#         while improved:
#             improved = False
            
#             # 2-opt improvement for each route
#             for i, route in enumerate(solution):
#                 if len(route) <= 4:
#                     continue
                    
#                 for j in range(1, len(route)-2):
#                     for k in range(j+1, len(route)-1):
#                         new_route = route[:j] + list(reversed(route[j:k+1])) + route[k+1:]
#                         if self.is_valid_route(new_route) and self._calculate_profit(new_route) > self._calculate_profit(route):
#                             solution[i] = new_route
#                             improved = True
            
#             # Inter-route client exchange
#             for i in range(len(solution)):
#                 for j in range(i+1, len(solution)):
#                     for pos1 in range(1, len(solution[i])-1):
#                         for pos2 in range(1, len(solution[j])-1):
#                             new_route1 = (solution[i][:pos1] + 
#                                         [solution[j][pos2]] + 
#                                         solution[i][pos1+1:])
#                             new_route2 = (solution[j][:pos2] + 
#                                         [solution[i][pos1]] + 
#                                         solution[j][pos2+1:])
                            
#                             if (self.is_valid_route(new_route1) and 
#                                 self.is_valid_route(new_route2)):
#                                 old_profit = (self._calculate_profit(solution[i]) + 
#                                             self._calculate_profit(solution[j]))
#                                 new_profit = (self._calculate_profit(new_route1) + 
#                                             self._calculate_profit(new_route2))
                                
#                                 if new_profit > old_profit:
#                                     solution[i] = new_route1
#                                     solution[j] = new_route2
#                                     improved = True
        
#         return solution

#     def _calculate_profit(self, route):
#         return sum(client.profit for client in route[1:-1])

#     def _update_pheromones(self, solutions, solution_qualities):
#         # Evaporation
#         for i in self.tau:
#             for j in self.tau[i]:
#                 self.tau[i][j] *= (1 - self.rho)

#         # Deposit new pheromones
#         for solution, quality in zip(solutions, solution_qualities):
#             if quality > 0:  # Only deposit for valid solutions
#                 deposit = self.Q * quality
#                 for route in solution:
#                     if self.is_valid_route(route):
#                         for i in range(len(route)-1):
#                             self.tau[route[i]][route[i+1]] += deposit
#                             self.tau[route[i+1]][route[i]] += deposit

#     def _calculate_solution_quality(self, solution):
#         if not solution or any(not self.is_valid_route(route) for route in solution):
#             return 0
        
#         total_profit = sum(self._calculate_profit(route) for route in solution)
#         total_time = sum(sum(self.get_distance(route[i], route[i+1]) 
#                            for i in range(len(route)-1)) for route in solution)
        
#         # Calculate coverage and efficiency metrics
#         served_clients = len({c.id for route in solution for c in route[1:-1]})
#         coverage_ratio = served_clients / len(self.clients)
#         time_efficiency = 1 - (total_time / (self.m * self.L))
        
#         return total_profit * (1 + 0.3 * coverage_ratio) * (1 + 0.2 * time_efficiency)

#     def solve(self):
#         for iteration in range(self.max_iterations):
#             solutions = []
#             qualities = []
            
#             for _ in range(self.n_ants):
#                 solution = self._construct_solution()
                
#                 # Apply local search to promising solutions
#                 if random.random() < 0.25:  # 25% chance
#                     solution = self._local_search(solution)
                
#                 quality = self._calculate_solution_quality(solution)
#                 solutions.append(solution)
#                 qualities.append(quality)
                
#                 if quality > self.best_fitness:
#                     self.best_fitness = quality
#                     self.best_solution = copy.deepcopy(solution)
            
#             self._update_pheromones(solutions, qualities)
            
#             if iteration % 10 == 0:
#                 print(f"Iteration {iteration}: Best Fitness = {self.best_fitness}")
        
#         return self.best_solution



# class GeneticTOP:
#     def __init__(self, start_point, end_point, clients, m, L):
#         self.start_point = start_point
#         self.end_point = end_point
#         self.clients = clients
#         self.m = m
#         self.L = L
#         n = len(clients)
#         self.population_size = min(200, n * 4)
#         self.tournament_size = max(4, self.population_size // 15)
#         self.elite_size = max(2, self.population_size // 20)
#         self.generations = min(300, n * 10)
#         self.mutation_rate = 0.2
#         self.crossover_rate = 0.8
#         self.best_solution = None
#         self.best_fitness = float('-inf')
#         self.max_stagnation = 30
#         self.client_distances = self._precompute_distances()

#     def _precompute_distances(self):
#         distances = {}
#         all_points = [self.start_point] + self.clients + [self.end_point]
#         for i, p1 in enumerate(all_points):
#             for p2 in all_points[i+1:]:
#                 dist = distance(p1, p2)
#                 distances[(p1.id, p2.id)] = distances[(p2.id, p1.id)] = dist
#         return distances

#     def get_distance(self, client1, client2):
#         return self.client_distances[(client1.id, client2.id)]

#     def is_valid_route(self, route):
#         if not route or len(route) < 2:
#             return False
#         if route[0] != self.start_point or route[-1] != self.end_point:
#             return False
#         if len(set(c.id for c in route[1:-1])) != len(route[1:-1]):
#             return False
#         total_time = sum(self.get_distance(route[i], route[i+1]) for i in range(len(route)-1))
#         return total_time <= self.L

#     def _create_initial_route(self, available_clients):
#         if not available_clients:
#             return [self.start_point, self.end_point]
#         route = [self.start_point]
#         current_time = 0
#         remaining = available_clients.copy()
#         while remaining:
#             feasible = []
#             for client in remaining:
#                 new_time = current_time + self.get_distance(route[-1], client) + self.get_distance(client, self.end_point)
#                 if new_time <= self.L:
#                     feasible.append((client, new_time))
#             if not feasible:
#                 break
#             client = max(feasible, key=lambda x: x[0].profit / (self.get_distance(route[-1], x[0]) + 0.1))[0]
#             route.append(client)
#             remaining.remove(client)
#             current_time += self.get_distance(route[-2], client)
#         route.append(self.end_point)
#         return route if len(route) > 2 else [self.start_point, self.end_point]

#     def _create_initial_solution(self):
#         solution = []
#         available_clients = set(self.clients)
#         for _ in range(self.m):
#             if not available_clients:
#                 break
#             route = self._create_initial_route(available_clients)
#             if len(route) > 2:
#                 solution.append(route)
#                 available_clients -= set(route[1:-1])
#         return solution

#     def _route_fitness(self, route):
#         if not self.is_valid_route(route):
#             return 0
#         return sum(c.profit for c in route[1:-1])

#     def fitness(self, solution):
#         if not solution:
#             return 0
#         total_profit = sum(self._route_fitness(route) for route in solution)
#         unique_clients = len({c.id for route in solution for c in route[1:-1]})
#         route_penalty = len(solution) / self.m if len(solution) < self.m else 1.0
#         return total_profit * route_penalty * (1 + 0.1 * unique_clients / len(self.clients))

#     def repair_solution(self, solution):
#         used_clients = set()
#         repaired = []
#         for route in solution:
#             if not route or len(route) < 2:
#                 continue
#             new_route = [self.start_point]
#             current_time = 0
#             for client in route[1:-1]:
#                 if client.id not in used_clients:
#                     new_time = current_time + self.get_distance(new_route[-1], client) + self.get_distance(client, self.end_point)
#                     if new_time <= self.L:
#                         new_route.append(client)
#                         used_clients.add(client.id)
#                         current_time += self.get_distance(new_route[-2], client)
#             if len(new_route) > 1:
#                 new_route.append(self.end_point)
#                 repaired.append(new_route)
#         return repaired[:self.m]

#     def crossover(self, parent1, parent2):
#         if not parent1 or not parent2 or random.random() > self.crossover_rate:
#             return copy.deepcopy(parent1), copy.deepcopy(parent2)
#         child1, child2 = [], []
#         used_clients1, used_clients2 = set(), set()
#         for i in range(min(len(parent1), len(parent2))):
#             if random.random() < 0.5:
#                 route1, route2 = parent1[i], parent2[i]
#             else:
#                 route1, route2 = parent2[i], parent1[i]
#             new_route1 = self._extract_valid_clients(route1, used_clients1)
#             new_route2 = self._extract_valid_clients(route2, used_clients2)
#             if len(new_route1) > 2:
#                 child1.append(new_route1)
#                 used_clients1.update(c.id for c in new_route1[1:-1])
#             if len(new_route2) > 2:
#                 child2.append(new_route2)
#                 used_clients2.update(c.id for c in new_route2[1:-1])
#         return self.repair_solution(child1), self.repair_solution(child2)

#     def _extract_valid_clients(self, route, used_clients):
#         if not route:
#             return [self.start_point, self.end_point]
#         new_route = [self.start_point]
#         current_time = 0
#         for client in route[1:-1]:
#             if client.id not in used_clients:
#                 new_time = current_time + self.get_distance(new_route[-1], client) + self.get_distance(client, self.end_point)
#                 if new_time <= self.L:
#                     new_route.append(client)
#                     current_time += self.get_distance(new_route[-2], client)
#         new_route.append(self.end_point)
#         return new_route

#     def mutation(self, solution):
#         if not solution or random.random() > self.mutation_rate:
#             return solution
#         mutated = copy.deepcopy(solution)
#         mutation_type = random.random()
#         if mutation_type < 0.4 and len(mutated) >= 2:
#             route1, route2 = random.sample(mutated, 2)
#             if len(route1) > 2 and len(route2) > 2:
#                 pos1, pos2 = random.randint(1, len(route1)-2), random.randint(1, len(route2)-2)
#                 route1[pos1], route2[pos2] = route2[pos2], route1[pos1]
#         elif mutation_type < 0.7:
#             route = random.choice(mutated)
#             if len(route) > 3:
#                 pos1, pos2 = sorted(random.sample(range(1, len(route)-1), 2))
#                 route[pos1:pos2+1] = reversed(route[pos1:pos2+1])
#         else:
#             if len(mutated) < self.m:
#                 used = {c.id for route in mutated for c in route[1:-1]}
#                 available = [c for c in self.clients if c.id not in used]
#                 if available:
#                     new_route = self._create_initial_route(set(available))
#                     if len(new_route) > 2:
#                         mutated.append(new_route)
#         return self.repair_solution(mutated)

#     def evolve(self):
#         population = [self._create_initial_solution() for _ in range(self.population_size)]
#         generations_without_improvement = 0
#         for generation in range(self.generations):
#             population.sort(key=self.fitness, reverse=True)
#             current_best_fitness = self.fitness(population[0])
#             if generation % 10 == 0:
#                 print(f"Generation {generation}: Best Fitness = {self.best_fitness}")
#             if current_best_fitness > self.best_fitness:
#                 self.best_fitness = current_best_fitness
#                 self.best_solution = copy.deepcopy(population[0])
#                 generations_without_improvement = 0
#             else:
#                 generations_without_improvement += 1
#             if generations_without_improvement > self.max_stagnation:
#                 print(f"Early stopping at generation {generation}")
#                 break
#             new_population = population[:self.elite_size]
#             while len(new_population) < self.population_size:
#                 parent1 = max(random.sample(population, self.tournament_size), key=self.fitness)
#                 parent2 = max(random.sample(population, self.tournament_size), key=self.fitness)
#                 child1, child2 = self.crossover(parent1, parent2)
#                 child1, child2 = self.mutation(child1), self.mutation(child2)
#                 if child1:
#                     new_population.append(child1)
#                 if child2 and len(new_population) < self.population_size:
#                     new_population.append(child2)
#             population = new_population
#         return self.best_solution


    # def evolve(self):
    #     # Initialize population with diverse solutions
    #     population = [self._create_initial_solution() 
    #                  for _ in range(self.population_size)]
        
    #     # Main evolution loop
    #     for generation in range(self.generations):
    #         # Calculate diversity metrics
    #         self.population_entropy = self._calculate_population_diversity(population)
    #         self.diversity_history.append(self.population_entropy)
            
    #         # Adjust parameters based on diversity
    #         self._adjust_parameters()
            
    #         # Sort population by fitness
    #         population.sort(key=self._adaptive_fitness, reverse=True)
            
    #         # Update best solution
    #         current_best_fitness = self._adaptive_fitness(population[0])
    #         if current_best_fitness > self.best_fitness:
    #             self.best_fitness = current_best_fitness
    #             self.best_solution = copy.deepcopy(population[0])
    #             self.generations_without_improvement = 0
    #         else:
    #             self.generations_without_improvement += 1
            
    #         # Early stopping check
    #         if (self.generations_without_improvement > self.max_stagnation and
    #             generation > self.generations // 3):
    #             print(f"Early stopping at generation {generation}")
    #             break
            
    #         if generation % 10 == 0:
    #             print(f"Generation {generation}: Best Fitness = {self.best_fitness:.2f}")
            
    #         # Create new population
    #         new_population = []
            
    #         # Elitism - preserve best solutions
    #         new_population.extend(copy.deepcopy(population[:self.elite_size]))
            
    #         # Generate rest of new population
    #         while len(new_population) < self.population_size:
    #             # Tournament selection
    #             parent1 = self._tournament_select(population)
    #             parent2 = self._tournament_select(population)
                
    #             # Crossover
    #             child1, child2 = self.crossover(parent1, parent2)
                
    #             # Mutation
    #             child1 = self.mutation(child1)
    #             child2 = self.mutation(child2)
                
    #             # Add valid children to new population
    #             if child1 and len(new_population) < self.population_size:
    #                 new_population.append(child1)
    #             if child2 and len(new_population) < self.population_size:
    #                 new_population.append(child2)
            
    #         # Update population
    #         population = new_population
        
    #     return self.best_solution

    # def _tournament_select(self, population):
    #     """Perform tournament selection."""
    #     tournament = random.sample(population, self.tournament_size)
    #     return max(tournament, key=self._adaptive_fitness)
    
    # def _adjust_parameters(self):
    #     """Adjust genetic parameters based on population diversity."""
    #     # Increase mutation rate if diversity is low
    #     if self.population_entropy < self.diversity_threshold:
    #         self.mutation_rate = min(0.5, self.mutation_rate * 1.1)
    #     else:
    #         self.mutation_rate = max(0.1, self.mutation_rate * 0.9)
        
    #     # Adjust crossover rate based on improvement
    #     if self.generations_without_improvement > self.max_stagnation // 2:
    #         self.crossover_rate = min(0.95, self.crossover_rate * 1.05)
    #     else:
    #         self.crossover_rate = max(0.75, self.crossover_rate * 0.95)
    def _adjust_parameters(self):
        """Adjust genetic parameters based on population diversity."""
        if self.population_entropy < 0.3:  # Plus strict threshold
            self.mutation_rate = min(0.8, self.mutation_rate * 1.2)  # More aggressive increase
            self.crossover_rate = max(0.6, self.crossover_rate * 0.95)
        elif self.population_entropy > 0.7:  # High diversity
            self.mutation_rate = max(0.2, self.mutation_rate * 0.9)
            self.crossover_rate = min(0.95, self.crossover_rate * 1.05)
        
        # Adjust based on improvement stagnation
        if self.generations_without_improvement > self.max_stagnation // 2:
            self.mutation_rate = min(0.9, self.mutation_rate * 1.3)
            self.tournament_size = max(2, self.tournament_size - 1)
        else:
            self.tournament_size = min(self.population_size // 10, self.tournament_size + 1)
    # def evolve(self):
    #     # Initialize population with diverse solutions
    #     population = [self._create_initial_solution() 
    #                 for _ in range(self.population_size)]
        
    #     # Main evolution loop
    #     for generation in range(self.generations):
    #         # Calculate diversity metrics
    #         self.population_entropy = self._calculate_population_diversity(population)
    #         self.diversity_history.append(self.population_entropy)
            
    #         # Adjust parameters based on diversity
    #         self._adjust_parameters()
            
    #         # Evaluate and sort population
    #         population_with_fitness = [(p, self._adaptive_fitness(p)) for p in population]
    #         population_with_fitness.sort(key=lambda x: x[1], reverse=True)
            
    #         # Update best solution
    #         current_best = population_with_fitness[0]
    #         if current_best[1] > self.best_fitness:
    #             self.best_fitness = current_best[1]
    #             self.best_solution = copy.deepcopy(current_best[0])
    #             self.generations_without_improvement = 0
    #         else:
    #             self.generations_without_improvement += 1
            
    #         # Early stopping check
    #         if (self.generations_without_improvement > self.max_stagnation and
    #             generation > self.generations // 3):
    #             print(f"Early stopping at generation {generation}")
    #             break
            
    #         if generation % 10 == 0:
    #             print(f"Generation {generation}: Best Fitness = {self.best_fitness:.2f}")
            
    #         # Create new population with diversity preservation
    #         new_population = []
            
    #         # Elite preservation with diversity check
    #         elite_added = set()
    #         for solution, fitness in population_with_fitness:
    #             if len(new_population) >= self.elite_size:
    #                 break
                
    #             # Check if solution is sufficiently different from already added ones
    #             is_diverse = True
    #             for added_solution in new_population:
    #                 diversity = self._calculate_route_diversity(solution[0], added_solution[0])
    #                 if diversity < 0.3:  # Threshold for considering solutions different
    #                     is_diverse = False
    #                     break
                
    #             if is_diverse:
    #                 new_population.append(copy.deepcopy(solution))
    #                 elite_added.add(id(solution))
            
    #         # Fill remaining population
    #         attempts = 0
    #         max_attempts = self.population_size * 2
            
    #         while len(new_population) < self.population_size and attempts < max_attempts:
    #             attempts += 1
                
    #             # Tournament selection with diversity consideration
    #             parent1 = self._diverse_tournament_select(population_with_fitness)
    #             parent2 = self._diverse_tournament_select(population_with_fitness, exclude=parent1)
                
    #             # Crossover and mutation
    #             child1, child2 = self.crossover(parent1, parent2)
    #             child1 = self.mutation(child1)
    #             child2 = self.mutation(child2)
                
    #             # Add children if they are sufficiently diverse
    #             for child in [child1, child2]:
    #                 if len(new_population) < self.population_size:
    #                     is_diverse = True
    #                     for existing in new_population:
    #                         diversity = self._calculate_route_diversity(child[0], existing[0])
    #                         if diversity < 0.2:  # Lower threshold for remaining population
    #                             is_diverse = False
    #                             break
                        
    #                     if is_diverse and child:
    #                         new_population.append(child)
            
    #         # If population is not full, fill with random new solutions
    #         while len(new_population) < self.population_size:
    #             new_solution = self._create_initial_solution()
    #             if new_solution:
    #                 new_population.append(new_solution)
            
    #         population = new_population
        
    #     return self.best_solution
    # def evolve(self):
    #     population = [self._create_initial_solution() 
    #                 for _ in range(self.population_size)]
        
    #     best_population_history = []
    #     best_fitness_history = []
    #     stagnation_counter = 0
    #     best_generation = 0
        
    #     for generation in range(self.generations):
    #         self.population_entropy = self._calculate_population_diversity(population)
    #         self.diversity_history.append(self.population_entropy)
            
    #         self._adjust_parameters()
            
    #         population_with_fitness = [(p, self._adaptive_fitness(p)) for p in population]
    #         population_with_fitness.sort(key=lambda x: x[1], reverse=True)
            
    #         current_best = population_with_fitness[0]
    #         best_fitness_history.append(current_best[1])
            
    #         if current_best[1] > self.best_fitness:
    #             self.best_fitness = current_best[1]
    #             self.best_solution = copy.deepcopy(current_best[0])
    #             self.generations_without_improvement = 0
    #             best_generation = generation
    #             stagnation_counter = 0
    #             best_population_history.append((copy.deepcopy(population), generation))
    #             if len(best_population_history) > 3:  # Keep only last 3 best populations
    #                 best_population_history.pop(0)
    #         else:
    #             self.generations_without_improvement += 1
    #             stagnation_counter += 1
            
    #         if generation % 10 == 0:
    #             print(f"Generation {generation}:")
    #             print(f"  Best Fitness = {self.best_fitness:.2f}")
    #             print(f"  Diversity = {self.population_entropy:.3f}")
    #             print(f"  Mutation Rate = {self.mutation_rate:.3f}")
    #             print(f"  Crossover Rate = {self.crossover_rate:.3f}")
    #             print(f"  Tournament Size = {self.tournament_size}")
            
    #         # Early stopping with backtracking
    #         if stagnation_counter > self.max_stagnation // 2:
    #             if best_population_history:
    #                 print(f"Backtracking to generation {best_population_history[-1][1]}")
    #                 population = copy.deepcopy(best_population_history[-1][0])
    #                 self.mutation_rate = min(0.95, self.mutation_rate * 1.5)
    #                 stagnation_counter = 0
    #             elif self.generations_without_improvement > self.max_stagnation and generation > self.generations // 3:
    #                 print(f"Early stopping at generation {generation}")
    #                 break
            
    #         new_population = []
    #         elite_added = set()
            
    #         for solution, fitness in population_with_fitness:
    #             if len(new_population) >= self.elite_size:
    #                 break
    #             is_diverse = True
    #             for added_solution in new_population:
    #                 diversity = self._calculate_route_diversity(solution[0], added_solution[0])
    #                 if diversity < 0.3:
    #                     is_diverse = False
    #                     break
    #             if is_diverse:
    #                 new_population.append(copy.deepcopy(solution))
    #                 elite_added.add(id(solution))
            
    #         attempts = 0
    #         max_attempts = self.population_size * 2
            
    #         while len(new_population) < self.population_size and attempts < max_attempts:
    #             attempts += 1
    #             parent1 = self._diverse_tournament_select(population_with_fitness)
    #             parent2 = self._diverse_tournament_select(population_with_fitness, exclude=parent1)
                
    #             child1, child2 = self.crossover(parent1, parent2)
    #             child1 = self.mutation(child1)
    #             child2 = self.mutation(child2)
                
    #             for child in [child1, child2]:
    #                 if len(new_population) < self.population_size:
    #                     is_diverse = True
    #                     for existing in new_population:
    #                         diversity = self._calculate_route_diversity(child[0], existing[0])
    #                         if diversity < 0.2:
    #                             is_diverse = False
    #                             break
    #                     if is_diverse and child:
    #                         new_population.append(child)
            
    #         while len(new_population) < self.population_size:
    #             new_solution = self._create_initial_solution()
    #             if new_solution:
    #                 new_population.append(new_solution)
            
    #         population = new_population
        
    #     print(f"\nFinal Best Solution found at generation {best_generation}")
    #     return self.best_solution

    # def evolve(self):
    #     population = [self._create_initial_solution() for _ in range(self.population_size)]
        
    #     best_population_history = []
    #     best_fitness_history = []
    #     stagnation_counter = 0
    #     backtrack_count = 0
    #     max_backtrack_attempts = 5
    #     min_tournament_size = 4
    #     best_generation = 0
    #     best_params_history = []
    #     quality_threshold = None
        
    #     for generation in range(self.generations):
    #         self.population_entropy = self._calculate_population_diversity(population)
    #         self.diversity_history.append(self.population_entropy)
            
    #         self._adjust_parameters()
    #         self.tournament_size = max(min_tournament_size, self.tournament_size)
            
    #         population_with_fitness = [(p, self._adaptive_fitness(p)) for p in population]
    #         population_with_fitness.sort(key=lambda x: x[1], reverse=True)
            
    #         current_best = population_with_fitness[0]
    #         best_fitness_history.append(current_best[1])
            
    #         if current_best[1] > self.best_fitness:
    #             self.best_fitness = current_best[1]
    #             self.best_solution = copy.deepcopy(current_best[0])
    #             self.generations_without_improvement = 0
    #             best_generation = generation
    #             stagnation_counter = 0
    #             backtrack_count = 0
                
    #             best_population_history.append((
    #                 copy.deepcopy(population), 
    #                 generation,
    #                 {'mutation': self.mutation_rate, 'crossover': self.crossover_rate, 'tournament': self.tournament_size}
    #             ))
    #             if len(best_population_history) > 3:
    #                 best_population_history.pop(0)
                    
    #             best_params_history.append({
    #                 'fitness': current_best[1],
    #                 'mutation': self.mutation_rate,
    #                 'crossover': self.crossover_rate,
    #                 'tournament': self.tournament_size,
    #                 'diversity': self.population_entropy
    #             })
                
    #             if quality_threshold is None:
    #                 quality_threshold = current_best[1] * 0.95
    #         else:
    #             self.generations_without_improvement += 1
    #             stagnation_counter += 1
            
    #         if generation % 10 == 0:
    #             print(f"Generation {generation}:")
    #             print(f"  Best Fitness = {self.best_fitness:.2f}")
    #             print(f"  Diversity = {self.population_entropy:.3f}")
    #             print(f"  Mutation Rate = {self.mutation_rate:.3f}")
    #             print(f"  Crossover Rate = {self.crossover_rate:.3f}")
    #             print(f"  Tournament Size = {self.tournament_size}")
            
    #         # Smart backtracking avec conditions multiples
    #         if (stagnation_counter > self.max_stagnation // 2 and 
    #             backtrack_count < max_backtrack_attempts and 
    #             best_population_history):
                
    #             avg_recent_fitness = sum(f for _, f in population_with_fitness[:5]) / 5
    #             if avg_recent_fitness < quality_threshold:
    #                 best_idx = random.randint(0, len(best_population_history)-1)
    #                 best_past = best_population_history[best_idx]
    #                 print(f"Smart backtracking to generation {best_past[1]} (attempt {backtrack_count + 1})")
                    
    #                 population = copy.deepcopy(best_past[0])
    #                 past_params = best_past[2]
                    
    #                 # Oscillation contrôlée des paramètres
    #                 self.mutation_rate = min(0.95, past_params['mutation'] * (1.2 if random.random() > 0.5 else 0.8))
    #                 self.crossover_rate = min(0.95, past_params['crossover'] * (1.1 if random.random() > 0.5 else 0.9))
    #                 self.tournament_size = max(min_tournament_size, past_params['tournament'] + random.randint(-2, 2))
                    
    #                 stagnation_counter = 0
    #                 backtrack_count += 1
    #                 continue
            
    #         if (self.generations_without_improvement > self.max_stagnation and 
    #             generation > self.generations // 3 and 
    #             backtrack_count >= max_backtrack_attempts):
    #             print(f"Early stopping at generation {generation}")
    #             break
            
    #         new_population = []
    #         elite_added = set()
            
    #         for solution, fitness in population_with_fitness:
    #             if len(new_population) >= self.elite_size:
    #                 break
    #             is_diverse = True
    #             for added_solution in new_population:
    #                 diversity = self._calculate_route_diversity(solution[0], added_solution[0])
    #                 if diversity < 0.3:
    #                     is_diverse = False
    #                     break
    #             if is_diverse:
    #                 new_population.append(copy.deepcopy(solution))
    #                 elite_added.add(id(solution))
            
    #         attempts = 0
    #         max_attempts = self.population_size * 2
            
    #         while len(new_population) < self.population_size and attempts < max_attempts:
    #             attempts += 1
    #             parent1 = self._diverse_tournament_select(population_with_fitness)
    #             parent2 = self._diverse_tournament_select(population_with_fitness, exclude=parent1)
                
    #             child1, child2 = self.crossover(parent1, parent2)
    #             child1 = self.mutation(child1)
    #             child2 = self.mutation(child2)
                
    #             for child in [child1, child2]:
    #                 if len(new_population) < self.population_size:
    #                     is_diverse = True
    #                     for existing in new_population:
    #                         diversity = self._calculate_route_diversity(child[0], existing[0])
    #                         if diversity < 0.2:
    #                             is_diverse = False
    #                             break
    #                     if is_diverse and child:
    #                         new_population.append(child)
            
    #         while len(new_population) < self.population_size:
    #             new_solution = self._create_initial_solution()
    #             if new_solution:
    #                 new_population.append(new_solution)
            
    #         population = new_population
        
    #     print(f"\nFinal Best Solution found at generation {best_generation}")
    #     if best_params_history:
    #         print("\nBest parameters configuration:")
    #         best_config = max(best_params_history, key=lambda x: x['fitness'])
    #         print(f"  Fitness: {best_config['fitness']:.2f}")
    #         print(f"  Mutation Rate: {best_config['mutation']:.3f}")
    #         print(f"  Crossover Rate: {best_config['crossover']:.3f}")
    #         print(f"  Tournament Size: {best_config['tournament']}")
    #         print(f"  Diversity: {best_config['diversity']:.3f}")
        
    #     return self.best_solution

    # def evolve(self):
    #     population = [self._create_initial_solution() for _ in range(self.population_size)]
        
    #     best_population_history = []
    #     best_fitness_history = []
    #     stagnation_counter = 0
    #     forced_perturbation_interval = 30
    #     backtrack_cycle = 0
    #     param_cycle_counter = 0
    #     parallel_populations = [population]
        
    #     def apply_forced_perturbation(pop):
    #         perturbed = copy.deepcopy(pop)
    #         num_to_perturb = len(pop) // 4
    #         for _ in range(num_to_perturb):
    #             idx = random.randint(0, len(pop)-1)
    #             perturbed[idx] = self._create_initial_solution()
    #         return perturbed
        
    #     for generation in range(self.generations):
    #         self.population_entropy = self._calculate_population_diversity(population)
    #         self.diversity_history.append(self.population_entropy)
            
    #         # Cycles des paramètres (20 générations par cycle)
    #         param_cycle = (generation % 20) / 20
    #         if param_cycle < 0.25:  # Exploration
    #             self.mutation_rate = min(0.9, self.mutation_rate * 1.1)
    #             self.tournament_size = max(4, self.tournament_size - 1)
    #         elif param_cycle < 0.5:  # Exploitation
    #             self.mutation_rate = max(0.2, self.mutation_rate * 0.9)
    #             self.tournament_size = min(20, self.tournament_size + 1)
    #         elif param_cycle < 0.75:  # Balance
    #             self.mutation_rate = 0.5
    #             self.tournament_size = 10
    #         else:  # Intensification
    #             self.mutation_rate = 0.3
    #             self.tournament_size = 15
            
    #         population_with_fitness = [(p, self._adaptive_fitness(p)) for p in population]
    #         population_with_fitness.sort(key=lambda x: x[1], reverse=True)
            
    #         current_best = population_with_fitness[0]
    #         best_fitness_history.append(current_best[1])
            
    #         # Gestion multi-stratégies
    #         if generation % forced_perturbation_interval == 0 and generation > 0:
    #             print(f"\nApplying forced perturbation at generation {generation}")
    #             population = apply_forced_perturbation(population)
    #             stagnation_counter = max(0, stagnation_counter - 10)
            
    #         if stagnation_counter >= 50:  # Forcer backtrack après 50 générations de stagnation
    #             backtrack_cycle += 1
    #             if best_population_history:
    #                 backtrack_idx = -1 if backtrack_cycle % 2 == 0 else 0  # Alterner entre récent et ancien
    #                 print(f"\nForced backtracking (cycle {backtrack_cycle}) at generation {generation}")
    #                 population = copy.deepcopy(best_population_history[backtrack_idx][0])
    #                 # Réinitialisation partielle
    #                 num_to_reinit = len(population) // 3
    #                 for _ in range(num_to_reinit):
    #                     idx = random.randint(0, len(population)-1)
    #                     population[idx] = self._create_initial_solution()
    #                 stagnation_counter = 0
    #             else:
    #                 print("\nRestarting population due to stagnation")
    #                 population = [self._create_initial_solution() for _ in range(self.population_size)]
    #                 stagnation_counter = 0
            
    #         if current_best[1] > self.best_fitness:
    #             self.best_fitness = current_best[1]
    #             self.best_solution = copy.deepcopy(current_best[0])
    #             self.generations_without_improvement = 0
    #             stagnation_counter = 0
                
    #             best_population_history.append((
    #                 copy.deepcopy(population),
    #                 generation,
    #                 {'mutation': self.mutation_rate, 'crossover': self.crossover_rate, 'tournament': self.tournament_size}
    #             ))
    #             if len(best_population_history) > 3:
    #                 best_population_history.pop(0)
    #         else:
    #             self.generations_without_improvement += 1
    #             stagnation_counter += 1
            
    #         if generation % 10 == 0:
    #             print(f"Generation {generation}:")
    #             print(f"  Best Fitness = {self.best_fitness:.2f}")
    #             print(f"  Diversity = {self.population_entropy:.3f}")
    #             print(f"  Mutation Rate = {self.mutation_rate:.3f}")
    #             print(f"  Crossover Rate = {self.crossover_rate:.3f}")
    #             print(f"  Tournament Size = {self.tournament_size}")
    #             print(f"  Stagnation Counter = {stagnation_counter}")
            
    #         new_population = []
            
    #         # Élites avec diversité garantie
    #         elite_size = self.elite_size
    #         for solution, fitness in population_with_fitness:
    #             if len(new_population) >= elite_size:
    #                 break
    #             is_diverse = True
    #             for added_solution in new_population:
    #                 if self._calculate_route_diversity(solution[0], added_solution[0]) < 0.3:
    #                     is_diverse = False
    #                     break
    #             if is_diverse:
    #                 new_population.append(copy.deepcopy(solution))
            
    #         # Génération du reste de la population
    #         while len(new_population) < self.population_size:
    #             parent1 = self._diverse_tournament_select(population_with_fitness)
    #             parent2 = self._diverse_tournament_select(population_with_fitness, exclude=parent1)
                
    #             child1, child2 = self.crossover(parent1, parent2)
                
    #             # Mutation adaptative
    #             if stagnation_counter > 30:  # Mutation plus agressive en stagnation
    #                 if random.random() < 0.5:
    #                     child1 = self.mutation(self.mutation(child1))  # Double mutation
    #                     child2 = self.mutation(self.mutation(child2))
    #             else:
    #                 child1 = self.mutation(child1)
    #                 child2 = self.mutation(child2)
                
    #             for child in [child1, child2]:
    #                 if len(new_population) < self.population_size and child:
    #                     new_population.append(child)
            
    #         population = new_population
            
    #         # Early stopping avec conditions multiples
    #         if (self.generations_without_improvement > self.max_stagnation and 
    #             generation > self.generations // 3 and 
    #             backtrack_cycle >= 3):  # Au moins 3 cycles de backtrack tentés
    #             print(f"\nEarly stopping at generation {generation}")
    #             break
        
    #     print(f"\nFinal Best Solution found at generation {best_population_history[-1][1]}")
    #     print(f"Total backtrack cycles: {backtrack_cycle}")
    #     print(f"Final stagnation counter: {stagnation_counter}")
        
    #     return self.best_solution  


    
    # def repair_solution(self, solution):
    #     if not solution:
    #         return []
            
    #     repaired = []
    #     used_clients = set()
        
    #     # Sort routes by profit density for repair
    #     routes_with_metrics = []
    #     for route in solution:
    #         if len(route) > 2:
    #             profit = sum(c.profit for c in route[1:-1])
    #             time = sum(self.get_distance(route[i], route[i+1]) 
    #                       for i in range(len(route)-1))
    #             density = profit / time if time > 0 else 0
    #             routes_with_metrics.append((route, density))
        
    #     # Process routes in order of decreasing profit density
    #     routes_with_metrics.sort(key=lambda x: x[1], reverse=True)
        
    #     for route, _ in routes_with_metrics:
    #         new_route = [self.start_point]
    #         current_time = 0
            
    #         for client in route[1:-1]:
    #             if client.id not in used_clients:
    #                 new_time = (current_time + 
    #                           self.get_distance(new_route[-1], client) + 
    #                           self.get_distance(client, self.end_point))
    #                 if new_time <= self.L:
    #                     new_route.append(client)
    #                     used_clients.add(client.id)
    #                     current_time += self.get_distance(new_route[-2], client)
            
    #         if len(new_route) > 1:
    #             new_route.append(self.end_point)
    #             repaired.append(new_route)
                
    #     return repaired[:self.m]  

    
    # def mutation(self, solution):
    #     if not solution or random.random() > self.mutation_rate:
    #         return solution
            
    #     mutated = copy.deepcopy(solution)
    #     mutation_type = random.random()
        
    #     if mutation_type < 0.3:  # Route shuffle
    #         if len(mutated) >= 2:
    #             i, j = random.sample(range(len(mutated)), 2)
    #             mutated[i], mutated[j] = mutated[j], mutated[i]
                
    #     elif mutation_type < 0.6:  # Client exchange
    #         if len(mutated) >= 2:
    #             route1, route2 = random.sample(mutated, 2)
    #             if len(route1) > 3 and len(route2) > 3:
    #                 pos1 = random.randint(1, len(route1)-2)
    #                 pos2 = random.randint(1, len(route2)-2)
    #                 route1[pos1], route2[pos2] = route2[pos2], route1[pos1]
                    
    #     elif mutation_type < 0.8:  # Route split
    #         if mutated:
    #             route = random.choice(mutated)
    #             if len(route) > 5:
    #                 split_point = random.randint(2, len(route)-3)
    #                 new_route1 = route[:split_point] + [self.end_point]
    #                 new_route2 = [self.start_point] + route[split_point:]
    #                 if len(mutated) < self.m:
    #                     mutated.remove(route)
    #                     if self.is_valid_route(new_route1):
    #                         mutated.append(new_route1)
    #                     if self.is_valid_route(new_route2):
    #                         mutated.append(new_route2)
                            
    #     else:  # Add new route with unserved clients
    #         if len(mutated) < self.m:
    #             used = {c.id for route in mutated for c in route[1:-1]}
    #             available = [c for c in self.clients if c.id not in used]
    #             if available:
    #                 new_route = self._create_route(set(available))
    #                 if len(new_route) > 2:
    #                     mutated.append(new_route)
        
    #     return self.repair_solution(mutated)


    # class AntColonyTOP:
#     def __init__(self, start_point, end_point, clients, m: int, L: float):
#         self.start_point = start_point
#         self.end_point = end_point
#         self.clients = clients
#         self.m = m  # number of routes
#         self.L = L  # time limit
        
#         # Problem size dependent parameters
#         n = len(clients)
#         self.n_ants = min(50, n * 2)  # number of ants scales with problem size
#         self.max_iterations = min(200, n * 5)
        
#         # ACO parameters
#         self.alpha = 1.0  # pheromone importance
#         self.beta = 2.0   # heuristic information importance
#         self.rho = 0.1    # evaporation rate
#         self.Q = 100.0    # pheromone deposit factor
        
#         # Initialize pheromone matrix
#         self.tau = {}
#         for i in [self.start_point] + clients + [self.end_point]:
#             self.tau[i] = {}
#             for j in [self.start_point] + clients + [self.end_point]:
#                 if i != j:
#                     self.tau[i][j] = 1.0

#         # Initialize heuristic information (eta)
#         self.eta = {}
#         for i in [self.start_point] + clients + [self.end_point]:
#             self.eta[i] = {}
#             for j in [self.start_point] + clients + [self.end_point]:
#                 if i != j:
#                     dist = distance(i, j)
#                     # Combine distance and profit in heuristic
#                     profit = j.profit if j != self.start_point and j != self.end_point else 0
#                     self.eta[i][j] = (1.0 + profit) / dist if dist > 0 else 1.0

#         # Dynamic parameters
#         self.local_search_freq = max(1, self.max_iterations // 10)
#         self.diversification_factor = 0.0
        
#         # Best solution tracking
#         self.best_solution = None
#         self.best_fitness = float('-inf')
#         self.iterations_without_improvement = 0
#         self.max_stagnation = 20

#     def is_valid_route(self, route):
#         if not route or len(route) < 2:
#             return False
#         if route[0] != self.start_point or route[-1] != self.end_point:
#             return False
#         if len(set(c.id for c in route[1:-1])) != len(route[1:-1]):
#             return False
#         total_time = sum(distance(route[i], route[i+1]) for i in range(len(route)-1))
#         return total_time <= self.L       

#     def _select_next_client(self, ant_route, current, available_clients):
#         if not available_clients:
#             return self.end_point

#         # Calculate remaining time
#         current_time = sum(distance(ant_route[i], ant_route[i+1]) 
#                          for i in range(len(ant_route)-1))
        
#         # Filter feasible clients
#         feasible = []
#         for client in available_clients:
#             time_to_client = distance(current, client)
#             time_to_end = distance(client, self.end_point)
#             temp_route = ant_route + [client, self.end_point]
#             if (current_time + time_to_client + time_to_end <= self.L and len(set(c.id for c in temp_route[1:-1])) == len(temp_route[1:-1])):
#                 feasible.append(client)
        
#         if not feasible:
#             return self.end_point

#         # Calculate selection probabilities
#         total = 0.0
#         probabilities = {}
        
#         for client in feasible:
#             # Include diversification factor in probability calculation
#             prob = ((self.tau[current][client] + self.diversification_factor) ** self.alpha * 
#                    self.eta[current][client] ** self.beta)
#             probabilities[client] = prob
#             total += prob

#         if total == 0.0:
#             return random.choice(feasible)

#         # Roulette wheel selection
#         r = random.random() * total
#         curr_sum = 0.0
#         for client in feasible:
#             curr_sum += probabilities[client]
#             if curr_sum >= r:
#                 return client
        
#         return feasible[-1]

#     def _construct_route(self, available_clients):
#         route = [self.start_point]
#         current = self.start_point
#         local_available = available_clients.copy()
        
#         while local_available:
#             next_client = self._select_next_client(route, current, local_available)
#             if next_client != self.end_point:
#                 test_route = route + [next_client, self.end_point]
#                 if not self.is_valid_route(test_route):
#                     next_client = self.end_point
#             if next_client == self.end_point:
#                 break
#             route.append(next_client)
#             current = next_client
#             local_available.remove(next_client)
        
#         route.append(self.end_point)
#         return route

#     def _construct_solution(self):
#         available_clients = set(self.clients)
#         solution = []
        
#         for _ in range(self.m):
#             if not available_clients:
#                 break
#             route = self._construct_route(available_clients)
#             if len(route) > 2:  # Only add non-empty routes
#                 solution.append(route)
#                 available_clients -= set(route[1:-1])
        
#         return solution

#     def _local_search(self, solution):
#         improved = True
#         while improved:
#             improved = False
            
#             # 2-opt improvement for each route
#             for i, route in enumerate(solution):
#                 if len(route) <= 4:  # Need at least 2 clients for 2-opt
#                     continue
                    
#                 for j in range(1, len(route)-2):
#                     for k in range(j+1, len(route)-1):
#                         new_route = route[:j] + list(reversed(route[j:k+1])) + route[k+1:]
#                         if self.is_valid_route(new_route):
#                             if (temps_total(new_route) <= self.L and 
#                                 profit_total(new_route) > profit_total(route)):
#                                 solution[i] = new_route
#                                 improved = True
            
#             # Inter-route client exchange
#             for i in range(len(solution)):
#                 for j in range(i+1, len(solution)):
#                     for pos1 in range(1, len(solution[i])-1):
#                         for pos2 in range(1, len(solution[j])-1):
#                             # Try swapping clients between routes
#                             new_route1 = (solution[i][:pos1] + 
#                                         [solution[j][pos2]] + 
#                                         solution[i][pos1+1:])
#                             new_route2 = (solution[j][:pos2] + 
#                                         [solution[i][pos1]] + 
#                                         solution[j][pos2+1:])
                            
#                             if (self.is_valid_route(new_route1) and
#                                 self.is_valid_route(new_route2)):
#                                 old_profit = profit_total(solution[i]) + profit_total(solution[j])
#                                 new_profit = profit_total(new_route1) + profit_total(new_route2)
#                                 if new_profit > old_profit:
#                                     solution[i] = new_route1
#                                     solution[j] = new_route2
#                                     improved = True
        
#         return solution

#     def _update_pheromones(self, solutions, solution_qualities):
#         # Evaporation
#         for i in self.tau:
#             for j in self.tau[i]:
#                 self.tau[i][j] *= (1 - self.rho)

#         # Deposit new pheromones
#         for solution, quality in zip(solutions, solution_qualities):
#             deposit = self.Q * quality
#             for route in solution:
#                 for i in range(len(route)-1):
#                     self.tau[route[i]][route[i+1]] += deposit
#                     self.tau[route[i+1]][route[i]] += deposit  # Symmetric deposit

#     def _calculate_solution_quality(self, solution):
#         if not solution:
#             return 0
        
#         total_profit = sum(profit_total(route) for route in solution)
#         total_time = sum(temps_total(route) for route in solution)
        
#         # Penalize solutions that violate time constraints
#         if any(temps_total(route) > self.L for route in solution):
#             return 0
        
#         # Calculate coverage ratio
#         served_clients = len({c.id for route in solution for c in route[1:-1]})
#         coverage_ratio = served_clients / len(self.clients)
        
#         # Calculate route balance factor
#         route_lengths = [len(route) - 2 for route in solution]
#         length_variance = np.var(route_lengths) if route_lengths else 0
#         balance_factor = 1 + 0.2 * (1 / (1 + length_variance))
        
#         # Combine factors
#         quality = (total_profit * 
#                   (1 + 0.3 * coverage_ratio) * 
#                   balance_factor * 
#                   (1 - total_time / (self.m * self.L)))
        
#         return quality

#     def solve(self):
#         # Initialize elite solutions archive
#         elite_solutions = []
#         elite_size = 3
#         stagnation_counter = 0
#         last_improvement = 0
        
#         # Adaptive parameters
#         min_alpha = 0.5
#         max_alpha = 3.0
#         min_beta = 1.0
#         max_beta = 4.0
        
#         # Initialize pheromone bounds
#         tau_max = 5.0
#         tau_min = 0.01
        
#         for iteration in range(self.max_iterations):
#             solutions = []
#             qualities = []
            
#             # Adjust parameters based on stagnation
#             if stagnation_counter > 10:
#                 # Increase exploration
#                 self.alpha = max(min_alpha, self.alpha * 0.9)
#                 self.beta = min(max_beta, self.beta * 1.1)
#                 self.rho = min(0.3, self.rho * 1.1)  # Increase evaporation
#                 # Reset pheromone levels partially
#                 if stagnation_counter % 20 == 0:
#                     for i in self.tau:
#                         for j in self.tau[i]:
#                             self.tau[i][j] = max(tau_min, self.tau[i][j] * 0.5)
#             else:
#                 # Favor exploitation
#                 self.alpha = min(max_alpha, self.alpha * 1.05)
#                 self.beta = max(min_beta, self.beta * 0.95)
#                 self.rho = max(0.1, self.rho * 0.95)

#             # Construct solutions with varying randomness
#             for ant in range(self.n_ants):
#                 # Adjust randomness based on ant index
#                 exploration_factor = 1.0 - (ant / self.n_ants)
#                 temp_alpha = self.alpha * (1 + exploration_factor * 0.5)
#                 temp_beta = self.beta * (1 - exploration_factor * 0.3)
                
#                 self.alpha, temp_alpha = temp_alpha, self.alpha  # Temporarily modify parameters
#                 self.beta, temp_beta = temp_beta, self.beta
                
#                 solution = self._construct_solution()
                
#                 # Restore original parameters
#                 self.alpha, self.beta = temp_alpha, temp_beta
                
#                 # Apply immediate local search to promising solutions
#                 if ant < self.n_ants // 4:  # Apply to top 25% of ants
#                     solution = self._local_search(solution)
                
#                 quality = self._calculate_solution_quality(solution)
#                 solutions.append(solution)
#                 qualities.append(quality)
                
#                 # Update best solution
#                 if quality > self.best_fitness:
#                     self.best_fitness = quality
#                     self.best_solution = copy.deepcopy(solution)
#                     last_improvement = iteration
#                     stagnation_counter = 0
                    
#                     # Update elite solutions
#                     elite_solutions.append((solution, quality))
#                     elite_solutions.sort(key=lambda x: x[1], reverse=True)
#                     elite_solutions = elite_solutions[:elite_size]
                
#             # Update pheromones with elite reinforcement
#             self._update_pheromones(solutions, qualities)
            
#             # Additional pheromone update from elite solutions
#             if elite_solutions:
#                 elite_deposit = self.Q * 2  # Stronger influence from elite solutions
#                 for elite_sol, elite_qual in elite_solutions:
#                     for route in elite_sol:
#                         for i in range(len(route)-1):
#                             self.tau[route[i]][route[i+1]] += elite_deposit
#                             self.tau[route[i+1]][route[i]] += elite_deposit
            
#             # Enforce pheromone bounds
#             for i in self.tau:
#                 for j in self.tau[i]:
#                     self.tau[i][j] = min(tau_max, max(tau_min, self.tau[i][j]))
            
#             # Dynamic convergence criteria
#             stagnation_counter += 1
#             if stagnation_counter >= 30 and iteration > 50:  # Minimum iterations before early stop
#                 if self.best_fitness >= 0.95 * max(qualities):  # Within 5% of current best
#                     print(f"Converged at iteration {iteration}")
#                     break
            
#             # Restart mechanism
#             if iteration - last_improvement > 40:  # No improvement for 40 iterations
#                 print(f"Restarting at iteration {iteration}")
#                 # Preserve best solution but reset pheromones partially
#                 for i in self.tau:
#                     for j in self.tau[i]:
#                         self.tau[i][j] = max(tau_min, min(tau_max, 
#                                         self.tau[i][j] * 0.5 + random.random() * 0.5))
#                 last_improvement = iteration  # Reset counter
#                 stagnation_counter = 0
                
#             if iteration % 10 == 0:
#                 print(f"Iteration {iteration}: Best Fitness = {self.best_fitness}")
                
#         return self.best_solution


# class AntColonyTOP:
#     def __init__(self, start_point, end_point, clients, m: int, L: float, debug=False):
#         self.start_point = start_point
#         self.end_point = end_point
#         self.clients = clients
#         self.m = m  # number of routes
#         self.L = L  # time limit
#         self.debug = debug
        
#         # Problem size dependent parameters
#         n = len(clients)
#         self.n_ants = min(50, n * 2)  # number of ants scales with problem size
#         self.max_iterations = min(200, n * 5)
        
#         # ACO parameters
#         self.alpha = 1.0  # pheromone importance
#         self.beta = 2.0   # heuristic information importance
#         self.rho = 0.1    # evaporation rate
#         self.Q = 100.0    # pheromone deposit factor
        
#         # Initialize pheromone matrix
#         self.tau = {}
#         for i in [self.start_point] + clients + [self.end_point]:
#             self.tau[i] = {}
#             for j in [self.start_point] + clients + [self.end_point]:
#                 if i != j:
#                     self.tau[i][j] = 1.0

#         # Initialize heuristic information (eta)
#         self.eta = {}
#         for i in [self.start_point] + clients + [self.end_point]:
#             self.eta[i] = {}
#             for j in [self.start_point] + clients + [self.end_point]:
#                 if i != j:
#                     dist = distance(i, j)
#                     # Combine distance and profit in heuristic
#                     profit = j.profit if j != self.start_point and j != self.end_point else 0
#                     self.eta[i][j] = (1.0 + profit) / dist if dist > 0 else 1.0

#         # Dynamic parameters
#         self.local_search_freq = max(1, self.max_iterations // 10)
#         self.diversification_factor = 0.0

#         # Statistics tracking
#         self.best_solution = None
#         self.best_fitness = float('-inf')
#         self.iterations_without_improvement = 0
#         self.max_stagnation = 20
        
#         # Statistics collection
#         self.stats_data = {
#             'iteration': [],
#             'best_fitness': [],
#             'avg_fitness': [],
#             'diversity': [],
#             'pheromone_avg': [],
#             'pheromone_max': [],
#             'pheromone_min': [],
#             'alpha': [],
#             'beta': [],
#             'rho': []
#         }

#     def is_valid_route(self, route):
#         if not route or len(route) < 2:
#             return False
#         if route[0] != self.start_point or route[-1] != self.end_point:
#             return False
#         if len(set(c.id for c in route[1:-1])) != len(route[1:-1]):
#             return False
#         total_time = sum(distance(route[i], route[i+1]) for i in range(len(route)-1))
#         return total_time <= self.L

#     def _select_next_client(self, ant_route, current, available_clients):
#         if not available_clients:
#             return self.end_point

#         # Calculate remaining time
#         current_time = sum(distance(ant_route[i], ant_route[i+1]) 
#                          for i in range(len(ant_route)-1))
        
#         # Filter feasible clients
#         feasible = []
#         for client in available_clients:
#             time_to_client = distance(current, client)
#             time_to_end = distance(client, self.end_point)
#             temp_route = ant_route + [client, self.end_point]
#             if (current_time + time_to_client + time_to_end <= self.L and 
#                 len(set(c.id for c in temp_route[1:-1])) == len(temp_route[1:-1])):
#                 feasible.append(client)
        
#         if not feasible:
#             return self.end_point

#         # Calculate selection probabilities
#         total = 0.0
#         probabilities = {}
        
#         for client in feasible:
#             # Include diversification factor in probability calculation
#             prob = ((self.tau[current][client] + self.diversification_factor) ** self.alpha * 
#                    self.eta[current][client] ** self.beta)
#             probabilities[client] = prob
#             total += prob

#         if total == 0.0:
#             return random.choice(feasible)

#         # Roulette wheel selection
#         r = random.random() * total
#         curr_sum = 0.0
#         for client in feasible:
#             curr_sum += probabilities[client]
#             if curr_sum >= r:
#                 return client
        
#         return feasible[-1]

#     def _construct_route(self, available_clients):
#         route = [self.start_point]
#         current = self.start_point
#         local_available = available_clients.copy()
        
#         while local_available:
#             next_client = self._select_next_client(route, current, local_available)
#             if next_client != self.end_point:
#                 test_route = route + [next_client, self.end_point]
#                 if not self.is_valid_route(test_route):
#                     next_client = self.end_point
#             if next_client == self.end_point:
#                 break
#             route.append(next_client)
#             current = next_client
#             local_available.remove(next_client)
        
#         route.append(self.end_point)
#         return route

#     def _construct_solution(self):
#         available_clients = set(self.clients)
#         solution = []
        
#         for _ in range(self.m):
#             if not available_clients:
#                 break
#             route = self._construct_route(available_clients)
#             if len(route) > 2:  # Only add non-empty routes
#                 solution.append(route)
#                 available_clients -= set(route[1:-1])
        
#         return solution

#     def _local_search(self, solution):
#         improved = True
#         while improved:
#             improved = False
            
#             # 2-opt improvement for each route
#             for i, route in enumerate(solution):
#                 if len(route) <= 4:  # Need at least 2 clients for 2-opt
#                     continue
                    
#                 for j in range(1, len(route)-2):
#                     for k in range(j+1, len(route)-1):
#                         new_route = route[:j] + list(reversed(route[j:k+1])) + route[k+1:]
#                         if self.is_valid_route(new_route):
#                             if (temps_total(new_route) <= self.L and 
#                                 profit_total(new_route) > profit_total(route)):
#                                 solution[i] = new_route
#                                 improved = True
            
#             # Inter-route client exchange
#             for i in range(len(solution)):
#                 for j in range(i+1, len(solution)):
#                     for pos1 in range(1, len(solution[i])-1):
#                         for pos2 in range(1, len(solution[j])-1):
#                             new_route1 = (solution[i][:pos1] + 
#                                         [solution[j][pos2]] + 
#                                         solution[i][pos1+1:])
#                             new_route2 = (solution[j][:pos2] + 
#                                         [solution[i][pos1]] + 
#                                         solution[j][pos2+1:])
                            
#                             if (self.is_valid_route(new_route1) and
#                                 self.is_valid_route(new_route2)):
#                                 old_profit = profit_total(solution[i]) + profit_total(solution[j])
#                                 new_profit = profit_total(new_route1) + profit_total(new_route2)
#                                 if new_profit > old_profit:
#                                     solution[i] = new_route1
#                                     solution[j] = new_route2
#                                     improved = True
        
#         return solution

#     def _update_pheromones(self, solutions, solution_qualities):
#         # Evaporation
#         for i in self.tau:
#             for j in self.tau[i]:
#                 self.tau[i][j] *= (1 - self.rho)

#         # Deposit new pheromones
#         for solution, quality in zip(solutions, solution_qualities):
#             deposit = self.Q * quality
#             for route in solution:
#                 for i in range(len(route)-1):
#                     self.tau[route[i]][route[i+1]] += deposit
#                     self.tau[route[i+1]][route[i]] += deposit  # Symmetric deposit

#     def _calculate_solution_quality(self, solution):
#         if not solution:
#             return 0
        
#         total_profit = sum(profit_total(route) for route in solution)
#         total_time = sum(temps_total(route) for route in solution)
        
#         # Penalize solutions that violate time constraints
#         if any(temps_total(route) > self.L for route in solution):
#             return 0
        
#         # Calculate coverage ratio
#         served_clients = len({c.id for route in solution for c in route[1:-1]})
#         coverage_ratio = served_clients / len(self.clients)
        
#         # Calculate route balance factor
#         route_lengths = [len(route) - 2 for route in solution]
#         length_variance = np.var(route_lengths) if route_lengths else 0
#         balance_factor = 1 + 0.2 * (1 / (1 + length_variance))
        
#         # Combine factors
#         quality = (total_profit * 
#                   (1 + 0.3 * coverage_ratio) * 
#                   balance_factor * 
#                   (1 - total_time / (self.m * self.L)))
        
#         return quality

#     def _calculate_diversity(self, solutions):
#         if not solutions:
#             return 0
        
#         diversity_sum = 0
#         comparisons = 0
        
#         for i in range(len(solutions)):
#             for j in range(i + 1, len(solutions)):
#                 sol1_clients = {c.id for route in solutions[i] for c in route[1:-1]}
#                 sol2_clients = {c.id for route in solutions[j] for c in route[1:-1]}
                
#                 if sol1_clients or sol2_clients:
#                     jaccard = len(sol1_clients & sol2_clients) / len(sol1_clients | sol2_clients)
#                     diversity_sum += 1 - jaccard
#                     comparisons += 1
        
#         return diversity_sum / max(1, comparisons)


#     # def solve(self):
#     #     # Initialize elite solutions archive
#     #     elite_solutions = []
#     #     elite_size = 3
#     #     stagnation_counter = 0
#     #     last_improvement = 0
        
#     #     # Adaptive parameters
#     #     min_alpha = 0.5
#     #     max_alpha = 3.0
#     #     min_beta = 1.0
#     #     max_beta = 4.0
        
#     #     # Initialize pheromone bounds
#     #     tau_max = 5.0
#     #     tau_min = 0.01
        
#     #     for iteration in range(self.max_iterations):
#     #         solutions = []
#     #         qualities = []
            
#     #         # Adjust parameters based on stagnation
#     #         if stagnation_counter > 10:
#     #             # Increase exploration
#     #             self.alpha = max(min_alpha, self.alpha * 0.9)
#     #             self.beta = min(max_beta, self.beta * 1.1)
#     #             self.rho = min(0.3, self.rho * 1.1)  # Increase evaporation
#     #             # Reset pheromone levels partially
#     #             if stagnation_counter % 20 == 0:
#     #                 for i in self.tau:
#     #                     for j in self.tau[i]:
#     #                         self.tau[i][j] = max(tau_min, self.tau[i][j] * 0.5)
#     #         else:
#     #             # Favor exploitation
#     #             self.alpha = min(max_alpha, self.alpha * 1.05)
#     #             self.beta = max(min_beta, self.beta * 0.95)
#     #             self.rho = max(0.1, self.rho * 0.95)

#     #         # Construct solutions with varying randomness
#     #         for ant in range(self.n_ants):
#     #             # Adjust randomness based on ant index
#     #             exploration_factor = 1.0 - (ant / self.n_ants)
#     #             temp_alpha = self.alpha * (1 + exploration_factor * 0.5)
#     #             temp_beta = self.beta * (1 - exploration_factor * 0.3)
                
#     #             self.alpha, temp_alpha = temp_alpha, self.alpha  # Temporarily modify parameters
#     #             self.beta, temp_beta = temp_beta, self.beta
                
#     #             solution = self._construct_solution()
                
#     #             # Restore original parameters
#     #             self.alpha, self.beta = temp_alpha, temp_beta
                
#     #             # Apply immediate local search to promising solutions
#     #             if ant < self.n_ants // 4:  # Apply to top 25% of ants
#     #                 solution = self._local_search(solution)
                
#     #             quality = self._calculate_solution_quality(solution)
#     #             solutions.append(solution)
#     #             qualities.append(quality)
                
#     #             # Update best solution
#     #             if quality > self.best_fitness:
#     #                 self.best_fitness = quality
#     #                 self.best_solution = copy.deepcopy(solution)
#     #                 last_improvement = iteration
#     #                 stagnation_counter = 0
                    
#     #                 # Update elite solutions
#     #                 elite_solutions.append((solution, quality))
#     #                 elite_solutions.sort(key=lambda x: x[1], reverse=True)
#     #                 elite_solutions = elite_solutions[:elite_size]

#     #         # Collect statistics
#     #         avg_quality = statistics.mean(qualities)
#     #         pheromone_values = [v for i in self.tau.values() for v in i.values()]

#     #         self.stats_data['iteration'].append(iteration)
#     #         self.stats_data['best_fitness'].append(self.best_fitness)
#     #         self.stats_data['avg_fitness'].append(avg_quality)
#     #         self.stats_data['diversity'].append(statistics.stdev(pheromone_values) if pheromone_values else 0)
#     #         self.stats_data['pheromone_avg'].append(statistics.mean(pheromone_values))
#     #         self.stats_data['pheromone_max'].append(max(pheromone_values))
#     #         self.stats_data['pheromone_min'].append(min(pheromone_values))
#     #         self.stats_data['alpha'].append(self.alpha)
#     #         self.stats_data['beta'].append(self.beta)
#     #         self.stats_data['rho'].append(self.rho)
            
#     #         if self.debug and iteration % 10 == 0:
#     #             print(f"\nIteration {iteration}:")
#     #             print(f"  Best Fitness: {self.best_fitness:.2f}")
#     #             print(f"  Average Fitness: {avg_quality:.2f}")
#     #             print(f"  Pheromone Diversity: {self.stats_data['diversity'][-1]:.3f}")
#     #             print(f"  Parameters - Alpha: {self.alpha:.3f}, Beta: {self.beta:.3f}, Rho: {self.rho:.3f}")
#     #             print(f"  Avg Pheromone: {self.stats_data['pheromone_avg'][-1]:.3f}")
                
#     #         # Update pheromones with elite reinforcement
#     #         self._update_pheromones(solutions, qualities)
            
#     #         # Additional pheromone update from elite solutions
#     #         if elite_solutions:
#     #             elite_deposit = self.Q * 2  # Stronger influence from elite solutions
#     #             for elite_sol, elite_qual in elite_solutions:
#     #                 for route in elite_sol:
#     #                     for i in range(len(route)-1):
#     #                         self.tau[route[i]][route[i+1]] += elite_deposit
#     #                         self.tau[route[i+1]][route[i]] += elite_deposit
            
#     #         # Enforce pheromone bounds
#     #         for i in self.tau:
#     #             for j in self.tau[i]:
#     #                 self.tau[i][j] = min(tau_max, max(tau_min, self.tau[i][j]))
            
#     #         # Dynamic convergence criteria
#     #         stagnation_counter += 1
#     #         if stagnation_counter >= 30 and iteration > 50:  # Minimum iterations before early stop
#     #             if self.best_fitness >= 0.95 * max(qualities):  # Within 5% of current best
#     #                 if self.debug:
#     #                     print(f"Converged at iteration {iteration}")
#     #                 break
            
#     #         # Restart mechanism
#     #         if iteration - last_improvement > 40:  # No improvement for 40 iterations
#     #             if self.debug:
#     #                 print(f"Restarting at iteration {iteration}")
#     #             # Preserve best solution but reset pheromones partially
#     #             for i in self.tau:
#     #                 for j in self.tau[i]:
#     #                     self.tau[i][j] = max(tau_min, min(tau_max, 
#     #                                     self.tau[i][j] * 0.5 + random.random() * 0.5))
#     #             last_improvement = iteration  # Reset counter
#     #             stagnation_counter = 0
        
#     #     if self.debug:
#     #         self._print_final_stats()
            
#     #     return self.best_solution
#     def solve(self):
#         start_time = time.time()
#         stagnation_counter = 0
        
#         for iteration in range(self.max_iterations):
#             # Construct solutions
#             solutions = []
#             qualities = []
            
#             for _ in range(self.n_ants):
#                 solution = self._construct_solution()
#                 quality = self._calculate_solution_quality(solution)
#                 solutions.append(solution)
#                 qualities.append(quality)
                
#                 # Update best solution
#                 if quality > self.best_fitness:
#                     self.best_fitness = quality
#                     self.best_solution = copy.deepcopy(solution)
#                     stagnation_counter = 0
#                 else:
#                     stagnation_counter += 1

#             # Update pheromones
#             self._update_pheromones(solutions, qualities)
            
#             # Collect statistics
#             avg_fitness = statistics.mean(qualities)
#             diversity = self._calculate_diversity(solutions)
#             pheromone_values = [v for d in self.tau.values() for v in d.values()]
            
#             self.stats_data['iteration'].append(iteration)
#             self.stats_data['best_fitness'].append(self.best_fitness)
#             self.stats_data['avg_fitness'].append(avg_fitness)
#             self.stats_data['diversity'].append(diversity)
#             self.stats_data['pheromone_avg'].append(statistics.mean(pheromone_values))
#             self.stats_data['pheromone_max'].append(max(pheromone_values))
#             self.stats_data['pheromone_min'].append(min(pheromone_values))
            
#             # Debug printing - now with more details like Genetic Algorithm
#             if self.debug and iteration % 10 == 0:
#                 print(f"\nIteration {iteration}:")
#                 print(f"  Best Fitness = {self.best_fitness:.2f}")
#                 print(f"  Average Fitness = {avg_fitness:.2f}")
#                 print(f"  Diversity = {diversity:.3f}")
#                 print(f"  Pheromone Stats:")
#                 print(f"    Average: {self.stats_data['pheromone_avg'][-1]:.3f}")
#                 print(f"    Max: {self.stats_data['pheromone_max'][-1]:.3f}")
#                 print(f"    Min: {self.stats_data['pheromone_min'][-1]:.3f}")
            
#             # Early stopping check
#             if stagnation_counter >= 50:  # Using same threshold as Genetic
#                 if self.debug:
#                     print(f"\nEarly stopping at iteration {iteration}")
#                     print(f"No improvement for {stagnation_counter} iterations")
#                 break

#         return self.best_solution

    # def _print_final_stats(self):
    #     """Print final statistics about the optimization process."""
    #     print("\n" + "="*50)
    #     print("Final Statistics:")
    #     print("="*50)
    #     print(f"Total Iterations: {len(self.stats_data['iteration'])}")
    #     print(f"Best Solution Fitness: {self.best_fitness:.2f}")
    #     print(f"Final Diversity: {self.stats_data['diversity'][-1]:.3f}")
        
    #     if self.best_solution:
    #         total_profit = sum(sum(c.profit for c in route[1:-1]) 
    #                         for route in self.best_solution)
    #         total_clients = sum(len(route)-2 for route in self.best_solution)
    #         total_time = sum(sum(distance(route[i], route[i+1])
    #                         for i in range(len(route)-1))
    #                     for route in self.best_solution)
            
    #         print(f"\nBest Solution Details:")
    #         print(f"Total Profit: {total_profit}")
    #         print(f"Total Clients Served: {total_clients}")
    #         print(f"Average Clients per Route: {total_clients/len(self.best_solution):.2f}")
    #         print(f"Total Time: {total_time:.2f}")
            
    #         print("\nParameter Evolution:")
    #         print(f"Final Alpha: {self.stats_data['alpha'][-1]:.3f}")
    #         print(f"Final Beta: {self.stats_data['beta'][-1]:.3f}")
    #         print(f"Final Rho: {self.stats_data['rho'][-1]:.3f}")
    #         print(f"Final Average Pheromone: {self.stats_data['pheromone_avg'][-1]:.3f}")

    # def get_stats(self):
    #     """Return collected statistics as a pandas DataFrame."""
    #     return pd.DataFrame(self.stats_data)
